<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<META NAME="generator" CONTENT="http://txt2tags.sf.net">
<TITLE> English Lexical Paradigms</TITLE>
</HEAD><BODY BGCOLOR="white" TEXT="black">
<P ALIGN="center"><CENTER><H1> English Lexical Paradigms</H1>
<FONT SIZE="4">
<I>Last update: 2007-06-25 18:09:50 CEST</I><BR>
</FONT></CENTER>

<P></P>
<HR NOSHADE SIZE=1>
<P></P>
    <UL>
    <LI><A HREF="#toc1">Parameters</A>
    <LI><A HREF="#toc2">Nouns</A>
      <UL>
      <LI><A HREF="#toc3">Compound nouns</A>
      <LI><A HREF="#toc4">Relational nouns</A>
      <LI><A HREF="#toc5">Proper names and noun phrases</A>
      </UL>
    <LI><A HREF="#toc6">Adjectives</A>
      <UL>
      <LI><A HREF="#toc7">Two-place adjectives</A>
      </UL>
    <LI><A HREF="#toc8">Adverbs</A>
    <LI><A HREF="#toc9">Prepositions</A>
    <LI><A HREF="#toc10">Verbs</A>
      <UL>
      <LI><A HREF="#toc11">Two-place verbs</A>
      <LI><A HREF="#toc12">Three-place verbs</A>
      <LI><A HREF="#toc13">Other complement patterns</A>
      </UL>
    </UL>

<P></P>
<HR NOSHADE SIZE=1>
<P></P>
<P>
Produced by 
gfdoc - a rudimentary GF document generator.
(c) Aarne Ranta (<A HREF="mailto:aarne@cs.chalmers.se">aarne@cs.chalmers.se</A>) 2002 under GNU GPL.
</P>
<P>
Aarne Ranta 2003--2005
</P>
<P>
This is an API for the user of the resource grammar 
for adding lexical items. It gives functions for forming
expressions of open categories: nouns, adjectives, verbs.
</P>
<P>
Closed categories (determiners, pronouns, conjunctions) are
accessed through the resource syntax API, <CODE>Structural.gf</CODE>. 
</P>
<P>
The main difference with <CODE>MorphoEng.gf</CODE> is that the types
referred to are compiled resource grammar types. We have moreover
had the design principle of always having existing forms, rather
than stems, as string arguments of the paradigms.
</P>
<P>
The structure of functions for each word class <CODE>C</CODE> is the following:
first we give a handful of patterns that aim to cover all
regular cases. Then we give a worst-case function <CODE>mkC</CODE>, which serves as an
escape to construct the most irregular words of type <CODE>C</CODE>.
However, this function should only seldom be needed: we have a
separate module <A HREF="../../english/IrregEng.gf"><CODE>IrregEng</CODE></A>, 
which covers irregular verbss.
</P>
<PRE>
    resource ParadigmsEng = open 
      (Predef=Predef), 
      Prelude, 
      MorphoEng,
      CatEng
      in {
</PRE>
<P></P>
<A NAME="toc1"></A>
<H2>Parameters</H2>
<P>
To abstract over gender names, we define the following identifiers.
</P>
<PRE>
    oper
      Gender : Type ; 
    
      human     : Gender ;
      nonhuman  : Gender ;
      masculine : Gender ;
</PRE>
<P></P>
<P>
To abstract over number names, we define the following.
</P>
<PRE>
      Number : Type ; 
    
      singular : Number ;
      plural   : Number ;
</PRE>
<P></P>
<P>
To abstract over case names, we define the following.
</P>
<PRE>
      Case : Type ;
    
      nominative : Case ;
      genitive   : Case ;
</PRE>
<P></P>
<P>
Prepositions are used in many-argument functions for rection.
The resource category <CODE>Prep</CODE> is used.
</P>
<A NAME="toc2"></A>
<H2>Nouns</H2>
<P>
Nouns are constructed by the function <CODE>mkN</CODE>, which takes a varying
number of arguments.
</P>
<PRE>
      mkN : overload {
</PRE>
<P></P>
<P>
The regular function captures the variants for nouns ending with
<I>s</I>,<I>sh</I>,<I>x</I>,<I>z</I> or <I>y</I>: <I>kiss - kisses</I>, <I>flash - flashes</I>; 
<I>fly - flies</I> (but <I>toy - toys</I>),
</P>
<PRE>
        mkN : (flash : Str) -&gt; N ;
</PRE>
<P></P>
<P>
In practice the worst case is to give singular and plural nominative.
</P>
<PRE>
        mkN : (man,men : Str) -&gt; N ;
</PRE>
<P></P>
<P>
The theoretical worst case: give all four forms.
</P>
<PRE>
        mkN : (man,men,man's,men's : Str) -&gt; N ;
</PRE>
<P></P>
<A NAME="toc3"></A>
<H3>Compound nouns</H3>
<P>
A compound noun is an uninflected string attached to an inflected noun,
such as <I>baby boom</I>, <I>chief executive officer</I>.
</P>
<PRE>
        mkN : Str -&gt; N -&gt; N
      } ;
</PRE>
<P></P>
<A NAME="toc4"></A>
<H3>Relational nouns</H3>
<P>
Relational nouns (<I>daughter of x</I>) need a preposition. 
</P>
<PRE>
      mkN2 : N -&gt; Prep -&gt; N2 ;
</PRE>
<P></P>
<P>
The most common preposition is <I>of</I>, and the following is a
shortcut for regular relational nouns with <I>of</I>.
</P>
<PRE>
      regN2 : Str -&gt; N2 ;
</PRE>
<P></P>
<P>
Use the function <CODE>mkPrep</CODE> or see the section on prepositions below to  
form other prepositions.
</P>
<P>
Three-place relational nouns (<I>the connection from x to y</I>) need two prepositions.
</P>
<PRE>
      mkN3 : N -&gt; Prep -&gt; Prep -&gt; N3 ;
</PRE>
<P></P>
<A NAME="toc5"></A>
<H3>Proper names and noun phrases</H3>
<P>
Proper names, with a regular genitive, are formed from strings.
</P>
<PRE>
      mkPN : overload {
    
        mkPN : Str -&gt; PN ;
</PRE>
<P></P>
<P>
Sometimes a common noun can be reused as a proper name, e.g. <I>Bank</I>
</P>
<PRE>
        mkPN : N -&gt; PN
      } ;
</PRE>
<P></P>
<A NAME="toc6"></A>
<H2>Adjectives</H2>
<PRE>
      mkA : overload {
</PRE>
<P></P>
<P>
For regular adjectives, the adverbial and comparison forms are derived. This holds
even for cases with the variations <I>happy - happily - happier - happiest</I>,
<I>free - freely - freer - freest</I>, and <I>rude - rudest</I>.
</P>
<PRE>
        mkA : (happy : Str) -&gt; A ;
</PRE>
<P></P>
<P>
However, the duplication of the final consonant cannot be predicted,
but a separate case is used to give the comparative
</P>
<PRE>
        mkA : (fat,fatter : Str) -&gt; A ;
</PRE>
<P></P>
<P>
As many as four forms may be needed.
</P>
<PRE>
        mkA : (good,better,best,well : Str) -&gt; A 
        } ;
</PRE>
<P></P>
<P>
To force comparison to be formed by <I>more - most</I>, 
the following function is used:
</P>
<PRE>
        compoundA : A -&gt; A ; -- -/more/most ridiculous
</PRE>
<P></P>
<A NAME="toc7"></A>
<H3>Two-place adjectives</H3>
<P>
Two-place adjectives need a preposition for their second argument.
</P>
<PRE>
      mkA2 : A -&gt; Prep -&gt; A2 ;
</PRE>
<P></P>
<A NAME="toc8"></A>
<H2>Adverbs</H2>
<P>
Adverbs are not inflected. Most lexical ones have position
after the verb. Some can be preverbal (e.g. <I>always</I>).
</P>
<PRE>
      mkAdv : Str -&gt; Adv ;
      mkAdV : Str -&gt; AdV ;
</PRE>
<P></P>
<P>
Adverbs modifying adjectives and sentences can also be formed.
</P>
<PRE>
      mkAdA : Str -&gt; AdA ;
</PRE>
<P></P>
<A NAME="toc9"></A>
<H2>Prepositions</H2>
<P>
A preposition as used for rection in the lexicon, as well as to
build <CODE>PP</CODE>s in the resource API, just requires a string.
</P>
<PRE>
      mkPrep : Str -&gt; Prep ;
      noPrep : Prep ;
</PRE>
<P></P>
<P>
(These two functions are synonyms.)
</P>
<A NAME="toc10"></A>
<H2>Verbs</H2>
<P>
Verbs are constructed by the function <CODE>mkV</CODE>, which takes a varying
number of arguments.
</P>
<PRE>
      mkV : overload {
</PRE>
<P></P>
<P>
The regular verb function recognizes the special cases where the last
character is <I>y</I> (<I>cry-cries</I> but <I>buy-buys</I>) or a sibilant
(<I>kiss-</I>kisses<I>, //jazz-jazzes</I>, <I>rush-rushes</I>, <I>munch - munches</I>, //
<I>fix - fixes</I>).
</P>
<PRE>
        mkV : (cry : Str) -&gt; V ;
</PRE>
<P></P>
<P>
Give the present and past forms for regular verbs where
the last letter is duplicated in some forms,
e.g. <I>rip - ripped - ripping</I>.
</P>
<PRE>
        mkV : (stop, stopped : Str) -&gt; V ;
</PRE>
<P></P>
<P>
There is an extensive list of irregular verbs in the module <CODE>IrregularEng</CODE>.
In practice, it is enough to give three forms, 
e.g. <I>drink - drank - drunk</I>.
</P>
<PRE>
        mkV : (drink, drank, drunk  : Str) -&gt; V ;
</PRE>
<P></P>
<P>
Irregular verbs with duplicated consonant in the present participle.
</P>
<PRE>
        mkV : (run, ran, run, running  : Str) -&gt; V ;
</PRE>
<P></P>
<P>
Except for <I>be</I>, the worst case needs five forms: the infinitive and
the third person singular present, the past indicative, and the
past and present participles.
</P>
<PRE>
        mkV : (go, goes, went, gone, going : Str) -&gt; V
      };
</PRE>
<P></P>
<P>
Verbs with a particle.
The particle, such as in <I>switch on</I>, is given as a string.
</P>
<PRE>
      partV  : V -&gt; Str -&gt; V ;
</PRE>
<P></P>
<P>
Reflexive verbs.
By default, verbs are not reflexive; this function makes them that.
</P>
<PRE>
      reflV  : V -&gt; V ;
</PRE>
<P></P>
<A NAME="toc11"></A>
<H3>Two-place verbs</H3>
<P>
Two-place verbs need a preposition, except the special case with direct object.
(transitive verbs). Notice that a particle comes from the <CODE>V</CODE>.
</P>
<PRE>
      mkV2 : overload {
        mkV2  : V -&gt; Prep -&gt; V2 ; -- believe in
        mkV2  : V -&gt; V2           -- kill
      };
</PRE>
<P></P>
<A NAME="toc12"></A>
<H3>Three-place verbs</H3>
<P>
Three-place (ditransitive) verbs need two prepositions, of which
the first one or both can be absent.
</P>
<PRE>
      mkV3     : V -&gt; Prep -&gt; Prep -&gt; V3 ;   -- speak, with, about
      dirV3    : V -&gt; Prep -&gt; V3 ;           -- give,_,to
      dirdirV3 : V -&gt; V3 ;                   -- give,_,_
</PRE>
<P></P>
<A NAME="toc13"></A>
<H3>Other complement patterns</H3>
<P>
Verbs and adjectives can take complements such as sentences,
questions, verb phrases, and adjectives.
</P>
<PRE>
      mkV0  : V -&gt; V0 ;
      mkVS  : V -&gt; VS ;
      mkV2S : V -&gt; Prep -&gt; V2S ;
      mkVV  : V -&gt; VV ;
      mkV2V : V -&gt; Prep -&gt; Prep -&gt; V2V ;
      mkVA  : V -&gt; VA ;
      mkV2A : V -&gt; Prep -&gt; V2A ;
      mkVQ  : V -&gt; VQ ;
      mkV2Q : V -&gt; Prep -&gt; V2Q ;
    
      mkAS  : A -&gt; AS ;
      mkA2S : A -&gt; Prep -&gt; A2S ;
      mkAV  : A -&gt; AV ;
      mkA2V : A -&gt; Prep -&gt; A2V ;
</PRE>
<P></P>
<P>
Notice: categories <CODE>V2S, V2V, V2Q</CODE> are in v 1.0 treated
just as synonyms of <CODE>V2</CODE>, and the second argument is given
as an adverb. Likewise <CODE>AS, A2S, AV, A2V</CODE> are just <CODE>A</CODE>.
<CODE>V0</CODE> is just <CODE>V</CODE>.
</P>
<PRE>
      V0, V2S, V2V, V2Q : Type ;
      AS, A2S, AV, A2V : Type ;
</PRE>
<P></P>

<!-- html code generated by txt2tags 2.3 (http://txt2tags.sf.net) -->
<!-- cmdline: txt2tags -thtml -\-toc english/ParadigmsEng.txt -->
</BODY></HTML>
