<html>
<body>
<i> Produced by 
gfdoc - a rudimentary GF document generator.
(c) Aarne Ranta (aarne@cs.chalmers.se) 2002 under GNU GPL.
 </i>
<p>
<h1></h1>

# -path=.:../abstract:../../prelude
<h1> English Lexical Paradigms</h1>
<p>
Aarne Ranta 2003
<p>
This is an API to the user of the resource grammar 
for adding lexical items. It give shortcuts for forming
expressions of basic categories: nouns, adjectives, verbs.

Closed categories (determiners, pronouns, conjunctions) are
accessed through the resource syntax API, <tt>Structural.gf</tt>. 
<p>
The main difference with <tt>MorphoEng.gf</tt> is that the types
referred to are compiled resource grammar types. We have moreover
had the design principle of always having existing forms, rather
than stems, as string
arguments of the paradigms.
<p>
The following modules are presupposed:
<pre>
  resource ParadigmsEng = open (Predef=Predef), Prelude, SyntaxEng, ResourceEng in {
</pre>

<h2> Parameters </h2>
<p>
To abstract over gender names, we define the following identifiers.
<pre>
  oper
    human    : Gender ;
    nonhuman : Gender ;
</pre>

To abstract over number names, we define the following.
<pre>
    singular : Number ;
    plural   : Number ;
</pre>

To abstract over case names, we define the following.
<pre>
    nominative : Case ;
    genitive   : Case ;
</pre>

<h2> Nouns</h2>
Worst case: give all four forms and the semantic gender.
In practice the worst case is just: give singular and plural nominative.
<pre>
  oper
    mkN  : (man,men,man's,men's : Str) -> Gender -> N ;
    nMan : (man,men : Str) -> Gender -> N ;
</pre>

Regular nouns, nouns ending with <i>s</i>, <i>y</i>, or <i>o</i>, and nouns with the same
plural form as the singular.
<pre>
    nReg   : Str -> Gender -> N ;   -- dog, dogs
    nKiss  : Str -> Gender -> N ;   -- kiss, kisses
    nFly   : Str -> Gender -> N ;   -- fly, flies
    nHero  : Str -> Gender -> N ;   -- hero, heroes (= nKiss !)
    nSheep : Str -> Gender -> N ;   -- sheep, sheep
</pre>

These use general heuristics, that recognizes the last letter. <b>N.B</b> it 
does not get right with <i>boy</i>, <i>rush</i>, since it only looks at one letter.
<pre>
    nHuman    : Str -> N ;  -- gambler/actress/nanny
    nNonhuman : Str -> N ;  -- dog/kiss/fly
</pre>

Nouns used as functions need a preposition. The most common is <i>of</i>.
<pre>
    mkFun : N -> Preposition -> Fun ;
  
    funHuman    : Str -> Fun ;  -- the father/mistress/daddy of 
    funNonhuman : Str -> Fun ;  -- the successor/address/copy of 
</pre>

Proper names, with their regular genitive.
<pre>
    pnReg : (John : Str) -> PN ;          -- John, John's
</pre>

The most common cases on the higher-level category <tt>CN</tt> have shortcuts.
The regular <i>y</i>/<i>s</i> variation is taken into account.
<pre>
    cnNonhuman : Str -> CN ;
    cnHuman    : Str -> CN ;
    npReg      : Str -> NP ;
</pre>

In some cases, you may want to make a complex <tt>CN</tt> into a function.
<pre>
    mkFunCN  : CN -> Preposition -> Fun ;
    funOfCN : CN -> Fun ;
</pre>

<h2> Adjectives</h2>
Non-comparison one-place adjectives just have one form.
<pre>
    mkAdj1 : (even : Str) -> Adj1 ;
</pre>

Two-place adjectives need a preposition as second argument.
<pre>
    mkAdj2 : (divisible, by : Str) -> Adj2 ;
</pre>

Comparison adjectives have three forms. The common irregular
cases are ones ending with <i>y</i> and a consonant that is duplicated;
the <i>y</i> ending is recognized by the function <tt>aReg</tt>.
<pre>
    mkAdjDeg : (good,better,best : Str) -> AdjDeg ;
  
    aReg        : (long  : Str) -> AdjDeg ;      -- long, longer, longest
    aFat        : (fat   : Str) -> AdjDeg ;      -- fat, fatter, fattest
    aRidiculous : (ridiculous : Str) -> AdjDeg ; -- -/more/most ridiculous
</pre>

On higher level, there are adjectival phrases. The most common case is
just to use a one-place adjective.
<pre>
    apReg : Str -> AP ;
</pre>

<h2> Adverbs</h2>
Adverbs are not inflected. Most lexical ones have position not
before the verb. Some can be preverbal (e.g. <i>always</i>).
<pre>
    mkAdv    : Str -> AdV ;
    mkAdvPre : Str -> AdV ;
</pre>

Adverbs modifying adjectives and sentences can also be formed.
<pre>
    mkAdA : Str -> AdA ;
    mkAdS : Str -> AdS ;
</pre>

Prepositional phrases are another productive form of adverbials.
<pre>
    mkPP : Str -> NP -> AdV ;
</pre>

<h2> Verbs</h2>
<p>
The fragment now has all verb forms, except the gerund/present participle.
Except for <i>be</i>, the worst case needs four forms: the infinitive and
the third person singular present, the past indicative, and the past participle.
<pre>
    mkV   : (go, goes, went, gone : Str) -> V ;
  
    vReg  : (walk : Str) -> V ;  -- walk, walks
    vKiss : (kiss : Str) -> V ;  -- kiss, kisses
    vFly  : (fly  : Str) -> V ;  -- fly, flies
    vGo   : (go   : Str) -> V ;  -- go, goes (= vKiss !)
</pre>

This generic function recognizes the special cases where the last
character is <i>y</i>, <i>s</i>, or <i>z</i>. It is not right for <i>finish</i> and <i>convey</i>.
<pre>
    vGen : Str -> V ; -- walk/kiss/fly
</pre>

The verbs <i>be</i> and <i>have</i> are special.
<pre>
    vBe   : V ;
    vHave : V ;
</pre>

Verbs with a particle.
<pre>
    vPart    : (go, goes, went, gone, up : Str) -> V ;
    vPartReg : (get,      up : Str) -> V ;    
</pre>

Two-place verbs, and the special case with direct object.
Notice that a particle can already be included in <tt>V</tt>.
<pre>
    mkTV  : V -> Str -> TV ;              -- look for, kill
  
    tvGen    : (look, for : Str) -> TV ;  -- look for, talk about
    tvDir    : V                 -> TV ;  -- switch off
    tvGenDir : (kill      : Str) -> TV ;  -- kill
</pre>

Regular two-place verbs with a particle.
<pre>
    tvPartReg : Str -> Str -> Str -> TV ; -- get, along, with
</pre>

Ditransitive verbs.
<pre>
    mkV3     : V -> Str -> Str -> V3 ;    -- speak, with, about
    v3Dir    : V -> Str -> V3 ;           -- give,_,to
    v3DirDir : V -> V3 ;                  -- give,_,_
</pre>

The definitions should not bother the user of the API. So they are
hidden from the document.
</body>
</html>
