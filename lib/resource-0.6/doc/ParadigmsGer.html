<html>
<body>
<i> Produced by 
gfdoc - a rudimentary GF document generator.
(c) Aarne Ranta (aarne@cs.chalmers.se) 2002 under GNU GPL.
 </i>
<p>
<h1></h1>

# -path=.:../abstract:../../prelude
<h1> German Lexical Paradigms</h1>
<p>
Aarne Ranta 2003
<p>
This is an API to the user of the resource grammar 
for adding lexical items. It give shortcuts for forming
expressions of basic categories: nouns, adjectives, verbs.

Closed categories (determiners, pronouns, conjunctions) are
accessed through the resource syntax API, <tt>Resource.gf</tt>. 
Their original typings via abstract syntax are in
<tt>Structural.gf</tt>, which also contains documentation.
<p>
The main difference with <tt>MorphoGer.gf</tt> is that the types
referred to are compiled resource grammar types. We have moreover
had the design principle of always having existing forms, not stems, as string
arguments of the paradigms.
<p>
The following modules are presupposed:
<pre>
  resource ParadigmsGer = 
    open Prelude, (Morpho=MorphoGer), SyntaxGer, ResourceGer in {
</pre>

<h2> Parameters </h2>
<p>
To abstract over gender names, we define the following identifiers.
<pre>
  oper
    masculine : Gender ;
    feminine  : Gender ;
    neuter    : Gender ;
</pre>

To abstract over case names, we define the following.
<pre>
    nominative : Case ;
    accusative : Case ;
    dative     : Case ;
    genitive   : Case ;
</pre>

To abstract over number names, we define the following.
<pre>
    singular : Number ;
    plural   : Number ;
</pre>

<h2> Nouns</h2>
Worst case: give all four singular forms, two plural forms (others + dative),
and the gender.
<pre>
    mkN  : (_,_,_,_,_,_ : Str) -> Gender -> N ; 
                                   -- mann, mann, manne, mannes, männer, männern
</pre>

Often it is enough with singular and plural nominatives, and singular
genitive. The plural dative
is computed by the heuristic that it is the same as the nominative this
ends with <i>n</i> or <i>s</i>, otherwise <i>n</i> is added.
<pre>
    nGen : Str -> Str -> Str ->  Gender -> N ; -- punkt,punktes,punkt
</pre>

Here are some common patterns. Singular nominative or two nominatives are needed.
Two forms are needed in case of Umlaut, which would be complicated to define.
For the same reason, we have separate patterns for multisyllable stems.

The weak masculine pattern <tt>nSoldat</tt> avoids duplicating the final <i>e</i>.
<pre>
    nRaum   : (_,_ : Str) -> N ;    -- Raum, (Raumes,) Räume (masc)
    nTisch  : Str -> N ;            -- Tisch, (Tisches, Tische) (masc)
    nVater  : (_,_ : Str) -> N ;    -- Vater, (Vaters,) Väter (masc)
    nFehler : Str -> N ;            -- Fehler, (fehlers, Fehler) (masc)
    nSoldat : Str -> N ;            -- Soldat (, Soldaten) ; Kunde (, Kunden) (masc)
</pre>

Neuter patterns. 
<pre>
    nBuch   : (_,_ : Str) -> N ;    -- Buch, (Buches, Bücher) (neut)
    nMesser : Str -> N ;            -- Messer, (Messers, Messer) (neut)
    nAuto   : Str -> N ;            -- Auto, (Autos, Autos) (neut)
</pre>

Feminine patterns. Duplicated <i>e</i> is avoided in <tt>nFrau</tt>.
<pre>
    nHand   : (_,_ : Str) -> N ;    -- Hand, Hände; Mutter, Mütter (fem)
    nFrau   : Str -> N ;            -- Frau (, Frauen) ; Wiese (, Wiesen) (fem)
</pre>

Nouns used as functions need a preposition. The most common is <i>von</i>.
<pre>
    mkFun  : N -> Preposition -> Case -> Fun ;
    funVon : N -> Fun ;
</pre>

Proper names, with their possibly
irregular genitive. The regular genitive is  <i>s</i>, omitted after <i>s</i>.
<pre>
    mkPN  : (karolus, karoli : Str) -> PN ; -- karolus, karoli
    pnReg : (Johann : Str) -> PN ;          -- Johann, Johanns ; Johannes, Johannes
</pre>

On the top level, it is maybe <tt>CN</tt> that is used rather than <tt>N</tt>, and
<tt>NP</tt> rather than <tt>PN</tt>.
<pre>
    mkCN  : N -> CN ;
    mkNP  : (karolus,karoli : Str) -> NP ;
  
    npReg : Str -> NP ;   -- Johann, Johanns
</pre>

In some cases, you may want to make a complex <tt>CN</tt> into a function.
<pre>
    mkFunCN  : CN -> Preposition -> Case -> Fun ;
    funVonCN : CN -> Fun ;
</pre>

<h2> Adjectives</h2>
Non-comparison one-place adjectives need two forms in the worst case:
the one in predication and the one before the ending <i>e</i>.
<pre>
    mkAdj1 : (teuer,teur : Str) -> Adj1 ;
</pre>

Invariable adjective are a special case.
<pre>
    adjInvar : Str -> Adj1 ;          -- prima
</pre>

The following heuristic recognizes the the end of the word, and builds
the second form depending on if it is <i>e</i>, <i>er</i>, or something else.
N.B. a contraction is made with <i>er</i>, which works for <i>teuer</i> but not
for <i>bitter</i>.
<pre>
    adjGen : Str -> Adj1 ;            -- gut; teuer; böse
</pre>

Two-place adjectives need a preposition and a case as extra arguments.
<pre>
    mkAdj2 : Adj1 -> Str -> Case -> Adj2 ;  -- teilbar, durch, acc
</pre>

Comparison adjectives may need three adjective, corresponding to the
three comparison forms. 
<pre>
    mkAdjDeg : (gut,besser,best : Adj1) -> AdjDeg ;
</pre>

In many cases, each of these adjectives is itself regular. Then we only
need three strings. Notice that contraction with <i>er</i> is not performed
(<i>bessere</i>, not <i>bessre</i>).
<pre>
    aDeg3 : (gut,besser,best : Str) -> AdjDeg ;
</pre>

In the completely regular case, the comparison forms are constructed by
the endings <i>er</i> and <i>st</i>.
<pre>
    aReg : Str -> AdjDeg ;    -- billig, billiger, billigst
</pre>

The past participle of a verb can be used as an adjective.
<pre>
    aPastPart : V -> Adj1 ;   -- gefangen
</pre>

On top level, there are adjectival phrases. The most common case is
just to use a one-place adjective. The variation in <tt>adjGen</tt> is taken
into account.
<pre>
    apReg : Str -> AP ;
</pre>

<h2> Verbs</h2>
<p>
The fragment only has present tense so far, but in all persons.
It also has the infinitive and the past participles.
The worst case macro needs four forms: : the infinitive and 
the third person singular (where Umlaut may occur), the singular imperative,
and the past participle.

The function recognizes if the stem ends with <i>s</i> or <i>t</i> and performs the
appropriate contractions.
<pre>
    mkV : (_,_,_,_ : Str) -> V ;   -- geben, gibt, gib, gegeben
</pre>

Regular verbs are those where no Umlaut occurs.
<pre>
    vReg  : Str -> V ;             -- führen
</pre>

The verbs 'be' and 'have' are special.
<pre>
    vSein  : V ;
    vHaben : V ;
</pre>

Some irregular verbs.
<pre>
    vFahren : V ;
</pre>

Verbs with a detachable particle, with regular ones as a special case.
<pre>
    vPart    :  (_,_,_,_,_ : Str) -> V ;     -- sehen, sieht, sieh, gesehen, aus
    vPartReg :  (_,_     : Str) -> V ;       -- bringen, um
    mkVPart  :  V -> Str -> V ;              -- vFahren, aus
</pre>

Two-place verbs, and the special case with direct object. Notice that
a particle can be included in a <tt>V</tt>.
<pre>
    mkTV     : V   -> Str -> Case -> TV ;    -- hören, zu, dative
  
    tvReg    : Str -> Str -> Case -> TV ;    -- hören, zu, dative
    tvDir    : V -> TV ;                     -- umbringen
    tvDirReg : Str -> TV ;                   -- lieben
</pre>

Three-place verbs require two prepositions and cases.
<pre>
    mkV3 : V -> Str -> Case -> Str -> Case -> V3 ;  -- geben,[],dative,[],accusative
</pre>

Sentence-complement verbs are just verbs.
<pre>
    mkVS : V -> VS ;
</pre>

Verb-complement verbs either need the <i>zu</i> particle or don't.
The ones that don't are usually auxiliary verbs.
<pre>
    vsAux : V -> VV ;
    vsZu  : V -> VV ;
</pre>

<h2> Adverbials</h2>
<p>
Adverbials for modifying verbs, adjectives, and sentences can be formed 
from strings.
<pre>
    mkAdV : Str -> AdV ;
    mkAdA : Str -> AdA ;
    mkAdS : Str -> AdS ;
</pre>

Prepositional phrases are another productive form of adverbials.
<pre>
    mkPP : Case -> Str -> NP -> AdV ;
</pre>

One can also use the function <tt>ResourceGer.PrepNP</tt> with one of the given
prepositions or a preposition formed by giving a string and a case:
<pre>
    mkPrep : Str -> Case -> Prep ;
</pre>

The definitions should not bother the user of the API. So they are
hidden from the document.
</body>
</html>
