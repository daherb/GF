<html>

<body bgcolor="#FFFFFF" text="#000000" >

<center>
<img SRC="../gf-logo.gif">

<h1>The GF Resource Grammar Library</h1>


<a href="http://www.cs.chalmers.se/~aarne">Aarne Ranta</a> 
2002-2004

<p>

Version 0.6: <a href="gf-resource.tgz">source package</a>.

<p>

Current languages: English, Finnish, French, German, Italian, Russian, Swedish.

</center>

<font size=2>
<b>News</b>. <br>

13/4/2004 Version 0.6 written using the module system of GF 2. Also an
extended coverage. The files are placed in separate subdirectories (one
per language) and have different names than before, so that file names
(without the extension <tt>.gf</tt>) are also legal module names.

<br>

15/8/2003 Version 0.4 with Finnish added. Some updates of the Russian modules.

<br>

25/6/2003 Release of GF 1.2 making it much more efficient to work with
resource grammars. See
<a href="http://www.cs.chalmers.se/~aarne/GF/doc/gf-1.2.html">highlights</a>.
Also <a href="gf-resource-0.3.tgz">source package version 0.3</a>
with some bug fixes.

<br>

5/6/2003. Russian resource modules by
<a href="http://www.cs.chalmers.se/~janna">Janna Khegai</a>.
Cyrillic strings in the files <tt>*.RusU.gf</tt> use UTF-8 encoding,
which is automatically detected by the Java GUI to GF. However, in web
browsers the encoding must be set manually.

<br>

3/6/2003. New version of this document, with separate sections
on application and resource grammarians' views and
added documentation
on the type system of each language <tt>X</tt>
in <tt>resource.X.gf</tt>.

<br>

23/5/2003. High-level lexicon access also in
French,
Italian,
and 
Swedish.

<br>

23/5/2003. 
Italian grammar based on generic Romance modules, shared with French.

<br>

14/4/2003. High-level access to define a lexicon in
English and German.

<p>

<i>
<b>Notice</b>. You need GF Version 2.0beta or later
to work with these resource grammars.
It is available from the 
<a href="http://www.cs.chalmers.se/~aarne/GF/">GF home page</a>.
</i>
</font>

<p>


<h2>Introduction</h2>

As programs in general can be divided into 
application programs and library programs, 
GF grammars can be divided into 
<b>application grammars</b> and 
<b>resource grammars</b>.
An application grammar is typically built around
a semantic model, which is formalized as the abstract
syntax of the language. Concrete syntax defines
a mapping from the abstract syntax into English or
Swedish or some other language.
A resource grammar is not based on semantics, but its
purpose is to define the linguistic "surface" structures
of some language. The availability of these structures makes it easier to
write application grammars.



<h3>Abstraction level</h3>

Resource grammars
<b>raise the level of abstraction in concrete syntax</b>.
The author of an application grammar is freed from thinking
about inflection, word order, etc, but can use structured
tree-like objects in linearization rules. For instance, to
express the linearization of the arithmetical predicate <i>even</i> 
in French, she no longer has to write
<pre>
  lin Even x = {s =
      table {
        m => x.s ++ 
             table {Ind  => "est" ;  Subj => "soit"} ! m ++
             table {Masc => "pair" ; Fem  => "paire"} ! x.g
      }
    } ;
</pre>
but simply
<pre>
  lin Even = predA1 (adjReg "pair") ;
</pre>
The author of the French resource grammar will have defined the
functions <tt>predAdj</tt> and <tt>adjReg</tt> in such a way that
they can be used in all applications.



<h3>Unity of language</h3>

In addition to high abstraction level, reusability, and the division
of labour, resource grammars have the virtue of making sense of the
<b>unity of a language</b> such as English: while application grammars
depend on applications, resource grammars depend on language.
What is more, resource grammars for related languages can
share much of their code: to what degree this can be done gives
a measure of how related the languages are.
Thus we find resource grammars to be an interesting linguistic
project in its own right.


<h3>Semantics</h3>

We leave it open if we can also explain the <b>semantics</b>
of resource grammar on the general level. The philosophy of GF,
inherited from logical frameworks,
is that semantics is only given to 
application grammars. (You can also compare them to Wittgenstein's
"language games").
This view gives us a lot of freedom in formulating resource grammars.
When describing them, we sometimes say that such-and-such construction
is likely to be ruled out by semantic reasons; what we mean is that
this will actually happen in application grammars; we do <i>not</i> 
mean that GF has no semantic rules.
An example of this is the free formation of question adverbials, e.g.
<i>From which city is every number even or odd?</i>.
The resource grammar makes it possible to form this question,
but it can hardly be grammatical in any sensible application grammar.



<h2>Programmer's view on resource grammars</h2>

The resource grammar library a hierarchical structure. Its main layers are
<ul>
<li> The language-dependent <b>core resources</b>, to be described below.
<li> The language-independent <b>core resource API</b>, 
     <a href="Combination.html"><tt>Combinations.gf</tt></a>.
     <a href="Structural.html"><tt>Structural.gf</tt></a>.
<li> The <b>derived resource libraries</b>, some of which are 
     language-dependent, some of which aren't. The most important
     ones are the language-dependent lexical paradigm modules
     <tt>ParadigmsX.gf</tt></a>.
</ul>
The core resources should not be needed by application grammarians: it should
be enough to use the core resource API and the derived libraries. If 
this is not the case, the best solution is to extend the derived resource
libraries or create new ones. 



<h3>Grammaticality guarantee via data abstraction</h3>

An important principle is that
<ul>
<li> the core resource API and the derived resource libraries guarantee
     that all type-correct uses of them preserve grammaticality.
</ul>
This principle is simultaneously a guidance for resource grammarians
and an argument for the application grammarian to use these libraries.
What we mean by "only using the libraries" is that
<ul>
<li> all <tt>lin</tt> and 
     <tt>lincat</tt> rules are built solely from library functions and
     argument variables.
</ul>
Thus for instance no records, tables, selections or projections should appear
in the rules. What we have achieved then is <b>total data abstraction</b>,
and the grammaticality guarantee can be given.

<p>

Since the resource grammars are work in progress, their coverage is not
yet sufficient for complete data abstraction. In addition, there may of course
be bugs in the resource grammars that destroy grammaticality. The GF group is
grateful for bug reports, requests, and contributions!

<p>

The most important exception to total data abstraction in practice is the
incompleteness of resource lexica. Since it is impossible to have
full coverage of all the words in a language, users often have to introduce
their own lexical entries, and thereby use literal strings in their GF code.
The safest and most convenient way of using this is via functions
defined in <tt>ParadigmsX.gf</tt> files. Using these functions guarantees
that the lexical entries created are type-correct. But nothing guards
against misspelling a word, picking a wrong inflectional pattern, or
a wrong inherent feature (such as gender).



<h3>The resource grammar documentation in <tt>gfdoc</tt></h3>

All documented GF grammars linked from this page
have been written in GF and then translated to HTML 
using a light-weight documentation tool,
<tt>gfdoc</tt>. The tool is available as a part of the GF
source code package, in the Haskell file
<tt>util/GFDoc.hs</tt> that can be run in the Hugs interpreter
by the script <tt>util/gfdoc</tt>. The program also has the
flag <tt>+latex</tt>, which produces output in Latex instead of
HTML.



<h3>The core resource API</h3>

The API is divided into two modules, <tt>Combiantions</tt> and
its extension <tt>Structural</tt>.

<p>

The file <a href="Combinations.html"><tt>Combinations.gf</tt></a>
gives the core resource type signatures of phrasal categories and
syntactic combination rules, together with some explanations
and examples. The examples are so far only in English, but their
equivalents are available in all of the languages for which the
API has been implemented.

<p>

The file <a href="Structural.html"><tt>Structurals.gf</tt></a>
gives a list of structural words such as determiners, pronouns,
prepositions, and conjunctions.

<p>

The file <tt>Structural.gf</tt> cannot be imported directly, but
via the generated files <tt>ResourceX.gf</tt> for each language <tt>X</tt>.
In these files, the <tt>fun/lin</tt> and <tt>cat/lincat</tt> judgements have been
translated into <tt>oper</tt> judgements.



<h3>The lexical paradigm modules</h3>

The lexical paradigm modules define, for
each lexical category, a <b>worst-case macro</b> for adding words
of that category by giving a sufficient number of characteristic
forms. In addition, the most common <b>regular paradigms</b> are
included, where it is enough just to give one form to generate
all the others. 

<p>

For example, the English paradigm module has the worst-case macro for nouns,
<pre>
  mkN : (man,men,man's,men's : Str) -> Gender -> N ;
</pre>
taking four forms and a gender (<tt>human</tt> or <tt>nonhuman</tt>,
as is also explained in the module). Its application
<pre>
  mkN "mouse" "mice" "mouse's" "mice's" nonhuman
</pre>
defines all information that is needed for the noun <i>mouse</i>.
There are also some regular patterns, for instance,
<pre>
  nReg  : Str -> Gender -> N ;   -- dog, dogs
  nKiss : Str -> Gender -> N ;   -- kiss, kisses
</pre>
examples of which are
<pre>
  nReg "car" nonhuman
  nKiss "waitress" human
</pre>

<p>

Here are the documented versions of the paradigm modules:
<ul>
<li> English: <a href="ParadigmsEng.html"><tt>ParadigmsEng.gf</tt></a>
<li> Finnish: <a href="ParadigmsFin.html"><tt>ParadigmsFin.gf</tt></a>
<li> French:  <a href="ParadigmsFra.html"><tt>ParadigmsFra.gf</tt></a>
<li> German:  <a href="ParadigmsDeu.html"><tt>ParadigmsDeu.gf</tt></a>
<li> Italian: <a href="ParadigmsIta.html"><tt>ParadigmsIta.gf</tt></a>
<li> Russian: <a href="ParadigmsRusU.html"><tt>ParadigmsRusU.gf</tt></a>
<li> Swedish: <a href="ParadigmsSwe.html"><tt>ParadigmsSwe.gf</tt></a>
</ul>


<h3>The derived resource libraries</h3>

The core resource grammar is minimal in the sense that it defines the
smallest syntactic combinations and has no redundancy. For applications, it
is usually more convenient to use combinations of the minimal rules.
Some such combinations are given in the <b>predication library</b>,
which defines the simultaneous applications of one- and two-place
verbs and adjectives to all their argument noun phrases. It also
defines some other constructions useful for logical and mathematical
applications.

<p>

The API of the predication library is in the file
<a href="abstract/Predication.html"><tt>Predication.gf</tt></a>.
What is imported is one of the language-dependent files,
<tt>X/PredicationX.gf</tt> for each language <tt>X</tt>.



<h3>The language-dependent type systems</h3>

Sometimes it is useful for the application grammarian to know what the
language-dependent linearizations types are for each category in the
core resource. These types are defined in the files <tt>CombinationsX.gf</tt>:
<ul>
<li> English: <a href="CombinationsEng.html"><tt>CombinationsEng.gf</tt></a>
<li> Finnish: <a href="CombinationsFin.html"><tt>CombinationsFin.gf</tt></a>
<li> French:  <a href="CombinationsFra.html"><tt>CombinationsFra.gf</tt></a>
<li> German:  <a href="CombinationsDeu.html"><tt>CombinationsDeu.gf</tt></a>
<li> Italian: <a href="CombinationsIta.html"><tt>CombinationsIta.gf</tt></a>
<li> Russian: <a href="CombinationsRusU.html"><tt>CombinationsRusU.gf</tt></a>
<li> Swedish: <a href="CombinationsSwe.html"><tt>CombinationsSwe.gf</tt></a>
</ul>
For the sake of uniformity, we have tried to use the same names
of parameter types when applicable. For instance, the gender parameter
is called <tt>Gender</tt> in every grammar, even though its values
differ. The definitions of the parameter
types are given in the files <tt>TypesX.gf</tt>. 
The application grammarian following the complete abstraction principle
should not use the parameter constructors directly, but rather the
names defined in <tt>ParadigmsX.gf</tt>.



<h2>Linguist's view on resource grammars</h2>

<h3>GF and other grammar formalisms</h3>

Linguists in particular might be interested in resource
grammars for their own sake, not as basis of applications.
Since few linguists are so far familiar with GF, we refer to the
<a href="http://www.cs.chalmers.se/~aarne/GF/">GF Homepage</a>
and especially to the 
<a href="http://www.cs.chalmers.se/~aarne/GF/Tutorial/">GF Tutorial</a>.
What comes here is a brief summary of the relation of GF to
other record-based formalisms.

<p>

The records of GF are much like feature structures in PATR or HPSG.
The main differences are that
<ul>
<li> GF has a type system inherited from
functional programming languages;
<li> GF records are primarily obtained as linearizations of trees, not
as parses of strings.
</ul>
The latter difference explains why a GF record typically carries more
information than a feature structure. For instance, the record describing
the French noun <i>cheval</i> is
<pre>
  {s = table {Sg => "cheval" ; Pl => "chevaux"} ; g = Masc} ;
</pre>
showing the full inflection table of the (abstract) noun <i>cheval</i>. 
A PATR record 
for the French word <i>cheval</i> would be
<pre>
  {s = "cheval" ; n = Sg ; g = Masc} ;
</pre>
showing just the information that can be gathered from the (concrete)
string <i>cheval</i>. 
There is a rather straightforward sense in which the PATR record is an 
<b>instance</b> of the GF record.

<p>

When generating language from syntax trees (or from logical formulas via
syntax trees), the record containing full inflection tables is an efficient
(linear-time) method of producing the correct forms.
This is important when text is generated in real time in
an interactive system.



<h2>The structure of core resource grammars</h2>

As explained above, the application grammarian's view on resource grammars
is through API modules. They are collections of type signatures of functions.
It is the task of linguists to define these functions.
The definitions are in the end given
in the <b>core resource grammars</b>.

<p>

We have divided the core resource grammar for each language <tt>X</tt> 
into the following parts:
<ul>
<li> Type system: <tt>types.X.gf</tt>
<li> Morphology: <tt>morpho.X.gf</tt>
<li> Syntax: <tt>syntax.X.gf</tt>
</ul>
To get the most powerful resource grammar for each language, one can use
these files directly. 

<p>

However, the languages we have studied have so much in common
that we have gathered a considerable set of categories and rules
in a <b>multilingual resource grammar</b>. Its parts are
<ul>
<li> Abstract syntax: <a href="Resource.html"><tt>Resource.gf</tt></a>
<li> Language-dependent concrete syntax: <tt>ResourceX.gf</tt></a> for
     each language.
</ul>
The advantage of using this API in application grammars is that
<b>their concrete syntax looks the same for all languages</b>
up to non-structural words. Thus it is possible to produce concrete syntaxes
for new languages without knowing almost anything about them.
The abstract syntax serves as a common API to the core resource grammar.


<h3>The code for the core resource grammars</h3>

The following links go to the <tt>gfdoc</tt>-generated
HTML files while showing the names of the GF files.
<ul>
<li> English: 
     <a href="types.Eng.html"><tt>types.Eng.gf</tt></a>,
     <a href="morpho.Eng.html"><tt>morpho.Eng.gf</tt></a>,
     <a href="syntax.Eng.html"><tt>syntax.Eng.gf</tt></a>.
<li> Finnish: 
     <a href="types.Fin.html"><tt>types.Fin.gf</tt></a>,
     <a href="morpho.Fin.html"><tt>morpho.Fin.gf</tt></a>,
     <a href="syntax.Fin.html"><tt>syntax.Fin.gf</tt></a>.
<li> Shared Romance:
     <a href="types.Romance.html"><tt>types.Romance.gf</tt></a>,
     <a href="syntax.Romance.html"><tt>syntax.Romance.gf</tt></a>,
<li> French:
     <a href="types.Fra.html"><tt>types.Fra.gf</tt></a>,
     <a href="morpho.Fra.html"><tt>morpho.Fra.gf</tt></a>,
     <a href="syntax.Fra.html"><tt>syntax.Fra.gf</tt></a>.
<li> Italian:
     <a href="types.Ita.html"><tt>types.Ita.gf</tt></a>,
     <a href="morpho.Ita.html"><tt>morpho.Ita.gf</tt></a>,
     <a href="syntax.Ita.html"><tt>syntax.Ita.gf</tt></a>.
<li> Russian:
     <a href="types.RusU.html"><tt>types.RusU.gf</tt></a>,
     <a href="morpho.RusU.html"><tt>morpho.RusU.gf</tt></a>,
     <a href="syntax.RusU.html"><tt>syntax.RusU.gf</tt></a>.
<li> German:
     <a href="types.Deu.html"><tt>types.Deu.gf</tt></a>,
     <a href="morpho.Deu.html"><tt>morpho.Deu.gf</tt></a>,
     <a href="syntax.Deu.html"><tt>syntax.Deu.gf</tt></a>.
<li> Swedish: 
     <a href="types.Swe.html"><tt>types.Swe.gf</tt></a>,
     <a href="morpho.Swe.html"><tt>morpho.Swe.gf</tt></a>,
     <a href="syntax.Swe.html"><tt>syntax.Swe.gf</tt></a>.
</ul>


<h2>Compiling and using the resource</h2>

If you want to use the resource grammars, 
you should download and unpack the
<a href="gf-resource.tgz">source package</a>.
At Chalmers, however, we keep the resource grammars in the
GF CVS archive, in the directory <tt>Grammars/resource/</tt>,
and you'd better take them that way. The package accessible through www
is usually not quite up to date.

<p>

To compile the resource into reusable operations, for all languages, type
<pre>
  make
</pre>
in the <tt>resource/</tt> directory.
This requires that you have a recent version of GF (>= 1.1).
What you get is a set of files with names <tt>res.X.gf</tt>.
The file <tt>res.Types.gf</tt> gives the type signatures
of the operations. You need never consult any of these files,
but mostly look into <tt>resource.Abs.gf</tt> for the type
signatures of syntactic structures.



<h2>Examples of using the resource grammars</h2>

<h3>A test suite</h3>

The grammars <tt>test.X.gf</tt> define a few expressions of each
lexical category and make it possible to test linearization, parsing,
random generation, and editing.


<h3>A database query language</h3>

The grammars <tt>database/(database | restaurant).X.gf</tt>
make use of the resource. The <tt>restaurant.X.gf</tt>
grammars are just one possible application building on the generic
<tt>database.X.gf</tt> grammars.
Look at the 
<a href="database/database.Abs.gf">abstract database syntax</a>
and, as an example, the
<a href="database/database.Fra.gf">French concrete syntax</a>.



<h3>A dialogue system for the video recorder</h3>

The grammars <tt>video/video.X.gf</tt> are meant to be a prototype
for dialogu systems. Look at the
<a href="video/video.Abs.gf">abstract video grammar</a>
and, as an example, the
<a href="video/video.Eng.gf">English concrete syntax</a>.



<h2>Functional morphology</h2>

Even though GF is a useful language for describing syntax and semantics, it
is not the optimal choice for morphology. 
One reason is the absence of low-level
programming, such as string matching. Another reason is efficiency.
In connection with the resource grammar project, we have started another
project, <b>functional morphology</b>, which uses Haskell to implement
morphology. Haskell morphologies can then be used for generating
GF morphologies, as exemplified by large parts of
<a href="morpho.Swe.html"><tt>morpho.Swe.gf</tt></a>.

<p>

Work is in progress to document functional morphology, but here is
a beginning: 
<ul>
<li> General library for defining morphologies: 
     <a href="General.html"><tt>General.hs</tt></a>.
<li> Swedish inflection engine: <a href="RulesSw.html"><tt>RulesSw.hs</tt></a>.
</ul>
(Notice that we have here used <tt>gfdoc</tt> on Haskell files.)

<p>

To see that it is nevertheless possible to implement morphology in GF, look
at the French morphology in
<a href="morpho.Fra.html"><tt>morpho.Fra.gf</tt></a>.
Its verb part is complete in the sense that it
implements all the 88 inflection tables of the Bescherelle.



<h2>Further reading</h2>

If you want to read an informal introduction to 
resource grammars, see these 
<a href="karlsruhe.ps.gz">slides</a>, written for a German computer science
audience. Or these
<a href="swedish.ps.gz">other slides</a>, written for a Swedish
linguistic audience.


</body>
</html>

