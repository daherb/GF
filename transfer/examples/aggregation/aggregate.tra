import prelude
import tree


-- aggreg specialized for Tree S
aggregS : Tree S -> Tree S
aggregS = aggreg S

-- For now, here's what we have to do:
aggreg : (A : Type) -> Tree A -> Tree A
aggreg _ t = 
  case t of
      ConjS c s1 s2 -> 
	case (aggreg ? s1, aggreg ? s2) of
	     (Pred np1 vp1, Pred np2 vp2) | eq NP (eq_Tree NP) np1 np2 -> 
			Pred np1 (ConjVP c vp1 vp2)
             (Pred np1 vp1, Pred np2 vp2) | eq VP (eq_Tree VP) vp1 vp2 -> 
	        	Pred (ConjNP c np1 np2) vp1
	     (s1',s2') -> ConjS c s1' s2'
      _ -> composOp ? ? compos_Tree ? aggreg t





{-
-- When the Transfer compiler gets meta variable inference,
-- we can write this:
aggreg : (A : Type) -> Tree A -> Tree A
aggreg _ t = 
  case t of
      ConjS c s1 s2 -> 
	case (aggreg ? s1, aggreg ? s2) of
		(Pred np1 vp1, Pred np2 vp2) | np1 == np2 -> 
			Pred np1 (ConjVP c vp1 vp2)
                (Pred np1 vp1, Pred np2 vp2) | vp1 == vp2 -> 
	        	Pred (ConjNP c np1 np2) vp1
		(s1',s2') -> ConjS c s1' s2'
      _ -> composOp ? ? ? ? aggreg t
-}


{-
-- If we added idden arguments, we could write something like this:
aggreg : (A : Type) => Tree A -> Tree A
aggreg t = 
  case t of
      ConjS c s1 s2 -> 
	case (aggreg s1, aggreg s2) of
		(Pred np1 vp1, Pred np2 vp2) | np1 == np2 -> 
			Pred np1 (ConjVP c vp1 vp2)
                (Pred np1 vp1, Pred np2 vp2) | vp1 == vp2 -> 
	        	Pred (ConjNP c np1 np2) vp1
		(s1',s2') -> ConjS c s1' s2'
      _ -> composOp aggreg t
-}
