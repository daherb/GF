import prelude
import tree

derive Eq Tree
derive Compos Tree


-- When the Transfer compiler gets meta variable inference,
-- we can write:
{-
aggreg : (A : Type) -> Tree A -> Tree A
aggreg _ t = 
  case t of
      ConjS c s1 s2 -> 
	case (aggreg ? s1, aggreg ? s2) of
		(Pred np1 vp1, Pred np2 vp2) | np1 == np2 -> 
			Pred np1 (ConjVP c vp1 vp2)
                (Pred np1 vp1, Pred np2 vp2) | vp1 == vp2 -> 
	        	Pred (ConjNP c np1 np2) vp1
		(s1',s2') -> ConjS c s1' s2'
      _ -> composOp ? ? ? ? aggreg t
-}

-- Adding hidden arguments, we could write something like:
{-
aggreg : (A : Type) => Tree A -> Tree A
aggreg t = 
  case t of
      ConjS c s1 s2 -> 
	case (aggreg s1, aggreg s2) of
		(Pred np1 vp1, Pred np2 vp2) | np1 == np2 -> 
			Pred np1 (ConjVP c vp1 vp2)
                (Pred np1 vp1, Pred np2 vp2) | vp1 == vp2 -> 
	        	Pred (ConjNP c np1 np2) vp1
		(s1',s2') -> ConjS c s1' s2'
      _ -> composOp aggreg t
-}


-- For now, here's what we have to do:

aggreg : (A : Type) -> Tree A -> Tree A
aggreg _ t = 
  case t of
      ConjS c s1 s2 -> 
	case (aggreg ? s1, aggreg ? s2) of
		(Pred np1 vp1, Pred np2 vp2) | eq_NP np1 np2 -> 
			Pred np1 (ConjVP c vp1 vp2)
                (Pred np1 vp1, Pred np2 vp2) | eq_VP vp1 vp2 -> 
	        	Pred (ConjNP c np1 np2) vp1
		(s1',s2') -> ConjS c s1' s2'
      _ -> composOp ? ? compos_Tree ? aggreg t


-- aggreg specialized for Tree S
aggregS : Tree S -> Tree S
aggregS = aggreg S

-- equality specialized for Tree NP
eq_NP : Tree NP -> Tree NP -> Bool
eq_NP = eq NP (eq_Tree NP)

-- equality specialized for Tree VP
eq_VP : Tree VP -> Tree VP -> Bool
eq_VP = eq VP (eq_Tree VP)

