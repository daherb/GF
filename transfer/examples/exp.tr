data Stm : Type where {} ;
data Exp : Type where {} ;
data Var : Type where {} ;
data Typ : Type where {} ;

data ListStm : Type where {} ;

data Tree : Type -> Type where {
  SDecl   : Tree Typ -> Tree Var -> Tree Stm ;
  SAss    : Tree Var -> Tree Exp -> Tree Stm ;
  SBlock  : Tree ListStm -> Tree Stm ;
  EAdd    : Tree Exp -> Tree Exp -> Tree Exp ;
  EStm    : Tree Stm -> Tree Exp ;
  EVar    : Tree Var -> Tree Exp ;
  EInt    : Integer -> Tree Exp ;
  V       : String -> Tree Var ;
  TInt    : Tree Typ ;
  TFloat  : Tree Typ ;

  NilStm  : Tree ListStm ;
  ConsStm : Tree Stm -> Tree ListStm -> Tree ListStm ;
 } ;

derive composOp Tree ;

rename : (String -> String) -> (C : Type) -> Tree C -> Tree C;
rename f C t = case t of {
		   V x -> V (f x) ;
		   _ -> composOp_Tree C (rename f) t;
                 } ;

