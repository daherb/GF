\documentclass[a4paper,11pt]{article}
\usepackage{mathpartir}

\begin{document}

\title{Transfer Type Checking}
\author{Bj\"orn Bringert \\ \texttt{bringert@cs.chalmers.se}}
\maketitle

\section{Type Checking Algorithm}

This is the beginnings of a type checking algorithm for the 
Transfer Core language. It is far from complete,
and some of the rules make no sense at all at the moment.

\subsection{Notation}

$\Delta$ is a set of constructor typings.

$\Gamma$ is a set of variable typings.

$\Delta;\Gamma \vdash t \uparrow A$ means that in the
variable typing context $\Gamma$ and the constructor
typing context $\Delta$, the type of $t$ can be inferred 
to be $A$.

$\Delta;\Gamma \vdash t \downarrow A$ means that in the
variable typing context $\Gamma$ and the constructor
typing context $\Delta$, the type of $t$ can be 
checked to be $A$.

$\Delta \vdash_p p \downarrow A; \Gamma$ means that
in the constructor typing context $\Delta$,
the pattern $p$ can matched against a value of type
$A$, and if the match succeeds, it will create
variable bindings with the typings $\Gamma$.


\subsection{Rules}

\begin{figure}
\begin{mathpar}

\inferrule[Type annotation]
{ \Delta;\Gamma \vdash t \downarrow A }
{ \Delta;\Gamma \vdash t : A \uparrow A }

\and

\inferrule[Variable]
{ x : A \in \Gamma }
{ \Delta;\Gamma \vdash x \uparrow A }

\and 

\inferrule[Constructor]
{ C : A \in \Delta }
{ \Delta;\Gamma \vdash C \uparrow A }

\and 

\inferrule[Function type]
{ \Delta;\Gamma \vdash A \uparrow Type \\
  \Delta;\Gamma, x : A \vdash B \uparrow Type }
{ \Delta;\Gamma \vdash (x : A) \rightarrow B \uparrow Type }

\and

\inferrule[Abstraction]
{ \Delta;\Gamma, x : A \vdash s \uparrow B }
{ \Delta;\Gamma \vdash \lambda x. s \downarrow (x : A) \rightarrow B }

\and 

\inferrule[Application]
{ \Delta;\Gamma \vdash s \uparrow (x : A) \rightarrow B \\ 
  \Delta;\Gamma \vdash t \downarrow A }
{ \Delta;\Gamma \vdash s t \uparrow B [x / t] }

\and 

\inferrule[Local definition]
{ \Delta;\Gamma \vdash s \uparrow A \\ 
  \Delta;\Gamma, s : A \vdash t \uparrow B }
{ \Delta;\Gamma \vdash \textrm{let} \ x = s \ \textrm{in} \ t \uparrow B }

\and 

\inferrule[Case analysis]
{ \Delta;\Gamma \vdash t \uparrow A \\
  \Delta \vdash_p p_1 \downarrow A; \Gamma' \\
  \Delta;\Gamma,\Gamma' \vdash g_1 \downarrow Bool \\
  \Delta;\Gamma,\Gamma' \vdash t_1 \uparrow B \\
  \ldots \\
  \Delta p_n \vdash_p A; \Gamma' \\
  \Delta;\Gamma, \Gamma' \vdash g_n \downarrow Bool \\
  \Delta;\Gamma, \Gamma' \vdash t_n \uparrow B \\
}
{ \Delta;\Gamma \vdash \textrm{case} \ s \ \textrm{of} \ \{ 
    p_1 \mid g_1 \rightarrow t_1;
    \ldots;
    p_n \mid g_n \rightarrow t_n
  \} \uparrow B }

\end{mathpar}
\caption{Basics.}
\label{fig:basics}
\end{figure}



\begin{figure}
\begin{mathpar}

\inferrule[Variable pattern]
{  }
{ \Delta \vdash_p x \downarrow \ A; \{ x : A \} }

\and 

\inferrule[Wildcard pattern]
{  }
{ \Delta \vdash_p \_ \ \downarrow \ A; \{ \} }

\and 

\inferrule[Constructor pattern]
{ C : (x_1 : T_1) \rightarrow \ldots \rightarrow T \in \Delta \\
  \Delta \vdash_p p_1 \downarrow T_1; \Gamma_1 \\
  \ldots \\
  \Delta \vdash_p p_n \downarrow T_n; \Gamma_n \\
  }
{ \Delta \vdash_p C p_1 \ldots p_n \ \downarrow \ T; \Gamma_1, \ldots, \Gamma_n }

\and 

\inferrule[Record pattern]
{ \Delta \vdash_p p_1 \ \downarrow \ T_1; \Gamma_1 \\
  \ldots \\
  \Delta \vdash_p p_n \ \downarrow \ T_n; \Gamma_n \\
  }
{ \Delta \vdash_p \textrm{rec} \ \{ l_1 = p_1; \ldots; l_n = p_n \} \ \downarrow \ 
  \textrm{sig} \ \{ l_1 : T_1; \ldots; l_n : T_n \}; \Gamma_1, \ldots, \Gamma_n }

\and 

\inferrule[Integer literal pattern]
{  }
{ \Delta \vdash_p integer \ \downarrow \ Integer; \{ \} }

\and 

\inferrule[String literal pattern]
{  }
{ \Delta \vdash_p string \ \downarrow \ String; \{ \} }

\and 

\end{mathpar}
\caption{Patterns.}
\label{fig:patterns}
\end{figure}


\begin{figure}
\begin{mathpar}

\inferrule[Record type]
{ \Delta;\Gamma \vdash T_1 \uparrow Type \\ 
  \ldots \\
  \Delta;\Gamma, l_1 : T_1, \ldots, l_{n-1} : T_{n-1} \vdash T_n \uparrow Type }
{ \Delta;\Gamma \vdash \textrm{sig} \{ l_1 : T_1, \ldots, l_n : T_n \} \uparrow Type }

\and

\inferrule[Record]
{ \Delta;\Gamma \vdash t_1 \uparrow T_1 \\ 
  \ldots \\
  \Delta;\Gamma \vdash t_n \uparrow T_n [l_{n-1} / t_{n-1}] \ldots [l_1 / t_1] }
{ \Delta;\Gamma \vdash \textrm{rec} \{ l_1 = t_1, \ldots, l_n = t_n \} 
  \uparrow \textrm{sig} \{ l_1 : T_1, \ldots, l_n : T_n \} }

\and 

\inferrule[Record projection]
{ \Delta;\Gamma \vdash t \uparrow \textrm{sig} \{ l : T \} }
{ \Delta;\Gamma \vdash t . l \uparrow T }

\end{mathpar}
\caption{Records.}
\label{fig:records}
\end{figure}


\begin{figure}
\begin{mathpar}

\inferrule[Integer type]
{ }
{ \Delta;\Gamma \vdash Integer \uparrow Type }

\and 

\inferrule[Integer literal]
{ }
{ \Delta;\Gamma \vdash integer \uparrow Integer }

\and 

\inferrule[Double type]
{ }
{ \Delta;\Gamma \vdash Double \uparrow Type }

\and 

\inferrule[Double literal]
{ }
{ \Delta;\Gamma \vdash double \uparrow Double }

\and 

\inferrule[String type]
{ }
{ \Delta;\Gamma \vdash String \uparrow Type }

\and 

\inferrule[String literal]
{ }
{ \Delta;\Gamma \vdash string \uparrow String }

\end{mathpar}
\caption{Primitive types.}
\label{fig:primitive-types}
\end{figure}


\end{document}
