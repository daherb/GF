----------------------------------------------------------------------
-- |
-- Maintainer  : PL
-- Stability   : (stable)
-- Portability : (portable)
--
-- > CVS $Date: 2005/05/13 12:40:19 $ 
-- > CVS $Author: peb $
-- > CVS $Revision: 1.9 $
--
-- All possible instantiations of different grammar formats used in conversion from GFC
-----------------------------------------------------------------------------


module GF.Conversion.Types where

import qualified GF.Infra.Ident as Ident (Ident, wildIdent, isWildIdent)
import qualified GF.Canon.AbsGFC as AbsGFC (CIdent(..))
import qualified GF.Grammar.Grammar as Grammar (Term)

import GF.Formalism.GCFG
import GF.Formalism.SimpleGFC
import GF.Formalism.MCFG
import GF.Formalism.CFG
import GF.Formalism.Utilities
import GF.Infra.Print
import GF.Data.Assoc

import Control.Monad (foldM)
import Data.List (intersperse)

----------------------------------------------------------------------
-- * basic (leaf) types

-- ** input tokens

type Token = String

-- ** function names

type Fun  = Ident.Ident
type Name = NameProfile Fun


----------------------------------------------------------------------
-- * Simple GFC

type SCat = Ident.Ident

constr2fun :: Constr -> Fun
constr2fun (AbsGFC.CIQ _ fun) = fun

-- ** grammar types

type SGrammar = SimpleGrammar SCat Name Token
type SRule    = SimpleRule    SCat Name Token

type SPath    = Path    SCat Token
type STerm    = Term    SCat Token
type SLinType = LinType SCat Token
type SDecl    = Decl    SCat

----------------------------------------------------------------------
-- * erasing MCFG

type EGrammar = MCFGrammar ECat Name ELabel Token
type ERule    = MCFRule    ECat Name ELabel Token
data ECat     = ECat SCat [Constraint]   deriving (Eq, Ord, Show)
type ELabel   = SPath

type Constraint = (SPath, STerm)

-- ** type coercions etc

initialECat :: SCat -> ECat
initialECat cat = ECat cat []

ecat2scat :: ECat -> SCat
ecat2scat (ECat cat _) = cat

ecatConstraints :: ECat -> [Constraint]
ecatConstraints (ECat _ cns) = cns

sameECat :: ECat -> ECat -> Bool
sameECat ec1 ec2 = ecat2scat ec1 == ecat2scat ec2

coercionName :: Name
coercionName = Name Ident.wildIdent [Unify [0]]

isCoercion :: Name -> Bool
isCoercion (Name fun [Unify [0]]) = Ident.isWildIdent fun
isCoercion _ = False

----------------------------------------------------------------------
-- * nonerasing MCFG

type MGrammar = MCFGrammar MCat Name MLabel Token
type MRule    = MCFRule    MCat Name MLabel Token
data MCat     = MCat ECat [ELabel]   deriving (Eq, Ord, Show)
type MLabel   = ELabel

mcat2ecat :: MCat -> ECat
mcat2ecat (MCat cat _) = cat

mcat2scat :: MCat -> SCat
mcat2scat = ecat2scat . mcat2ecat

----------------------------------------------------------------------
-- * CFG

type CGrammar = CFGrammar CCat Name Token
type CRule    = CFRule    CCat Name Token
data CCat     = CCat      ECat ELabel  deriving (Eq, Ord, Show)

ccat2ecat :: CCat -> ECat
ccat2ecat (CCat cat _) = cat

ccat2scat :: CCat -> SCat
ccat2scat = ecat2scat . ccat2ecat

----------------------------------------------------------------------
-- * pretty-printing

instance Print ECat where
    prt (ECat cat constrs) = prt cat ++ "{" ++ 
			     concat [ prt path ++ "=" ++ prt term ++ ";" |
				      (path, term) <- constrs ] ++ "}"

instance Print MCat where
    prt (MCat cat labels) = prt cat ++ prt labels

instance Print CCat where
    prt (CCat cat label) = prt cat ++ prt label


----------------------------------------------------------------------
-- * other printing facilities

-- ** printing grammars as Haskell files

prtHsSGrammar :: SGrammar -> String
prtHsSGrammar rules = "-- Simple GFC grammar as a Haskell file\n" ++
		"-- autogenerated from the Grammatical Framework\n\n" ++
                "import GF.Formalism.GCFG\n" ++
		"import GF.Formalism.SimpleGFC\n" ++ 
                "import GF.Formalism.Utilities\n" ++
		"--import GF.Conversion.Types\n" ++
		"import GF.Canon.AbsGFC (CIdent(..), Label(..))\n" ++
		"import GF.Infra.Ident (Ident(..))\n" ++
		"\ngrammar :: SimpleGrammar Ident (NameProfile Ident) String\n" ++ 
		-- "\ngrammar :: SGrammar\n" ++
		"grammar = \n\t[ " ++ 
		concat (intersperse "\n\t, " (map show rules)) ++
                "\n\t]\n\n"

prtHsMGrammar :: MGrammar -> String
prtHsMGrammar rules = "-- Multiple context-free grammar as a Haskell file\n" ++
		      "-- autogenerated from the Grammatical Framework\n\n" ++
		      "import GF.Formalism.GCFG\n" ++ 
		      "import GF.Formalism.MCFG\n" ++ 
                      "import GF.Formalism.Utilities\n" ++
                      "\ngrammar :: MCFGrammar String (NameProfile String) String String\n" ++
		      "grammar = \n\t[ " ++ 
		      concat (intersperse "\n\t, " (map prtHsMRule rules)) ++
                      "\n\t]\n\n" 
    where prtHsMRule (Rule (Abs cat cats (Name fun profiles)) (Cnc lcat lcats lins)) =
	      show (Rule (Abs (prt cat) (map prt cats) (Name (prt fun) (map cnvHsProfile profiles)))
		         (Cnc (map prt lcat) (map (map prt) lcats) (map cnvHsLin lins)))
	  cnvHsLin (Lin lbl syms) = Lin (prt lbl) (map (mapSymbol prtMArg id) syms)
	  prtMArg  (cat, lbl, nr) = (prt cat, prt lbl, nr)

prtHsCGrammar :: CGrammar -> String
prtHsCGrammar rules = "-- Context-free grammar as a Haskell file\n" ++
		      "-- autogenerated from the Grammatical Framework\n\n" ++
		      "import GF.Formalism.CFG\n" ++ 
                      "import GF.Formalism.Utilities\n" ++
                      "\ngrammar :: CFGrammar String (NameProfile String) String\n" ++
		      "grammar = \n\t[ " ++ 
		      concat (intersperse "\n\t, " (map prtHsCRule rules)) ++
                      "\n\t]\n\n" 
    where prtHsCRule (CFRule cat syms (Name fun profiles)) = 
	      show (CFRule (prt cat) (map (mapSymbol prt id) syms) 
	                   (Name (prt fun) (map cnvHsProfile profiles)))

cnvHsProfile (Unify args) = Unify args
cnvHsProfile (Constant forest) = Constant (fmap prt forest)

-- ** printing grammars as Prolog files

prtPlMGrammar :: MGrammar -> String
prtPlMGrammar rules = ":- op(1100, xfx, ':=').\n" ++ 
		      ":- op(1000, xfx, '--->').\n" ++ 
		      ":- op(200, xfx, '@').\n\n" ++ 
		      "%% Fun/ProfileList : Cat ---> [Cat,...] := [Lbl=SymbolList,...]\n" ++
		      concatMap prtPlMRule rules
    where prtPlMRule (Rule (Abs cat cats (Name fun profiles)) (Cnc _lcat _lcats lins)) =
	      prtPlQuoted fun ++ "/" ++ 
	      "[" ++ prtSep "," (map prtPlProfile profiles) ++ "] : " ++
	      prtPlQuoted cat ++ " ---> " ++ 
	      "[" ++ prtSep ", " (map prtPlQuoted cats) ++ "] := \n" ++
	      "\t[ " ++ prtSep "\n\t, " (map prtLin lins) ++ "\n\t].\n"
	  prtLin (Lin lbl lin) = prtPlQuoted lbl ++ " = " ++ 
				 "[" ++ prtSep ", " (map prtSymbol lin) ++ "]"
	  prtSymbol (Cat (cat, lbl, nr)) = prtPlQuoted cat ++ "@" ++ show nr ++ "-" ++ prtPlQuoted lbl 
	  prtSymbol (Tok tok) = "[" ++ prtPlQuoted tok ++ "]"

prtPlCGrammar :: CGrammar -> String
prtPlCGrammar rules = ":- op(1000, xfx, '--->').\n\n" ++ 
		      "%% Fun/ProfileList : Cat ---> [Symbol,...]\n" ++
		      concatMap prtPlCRule rules
    where prtPlCRule (CFRule cat syms (Name fun profiles)) = 
	      prtPlQuoted fun ++ "/" ++
	      "[" ++ prtSep "," (map prtPlProfile profiles) ++ "] : " ++
	      prtPlQuoted cat ++ " ---> " ++ 
	      "[" ++ prtSep ", " (map prtSymbol syms) ++ "].\n"
	  prtSymbol (Cat cat) = prtPlQuoted cat 
	  prtSymbol (Tok tok) = "[" ++ prtPlQuoted tok ++ "]"

prtPlProfile (Unify args) = show args
prtPlProfile (Constant forest) = prtPlForest forest

prtPlForest (FMeta) = "_META_"
prtPlForest (FNode fun fss) = prtPlQuoted fun ++ "^" ++ prtFss fss
    where prtFss fss = "[" ++ prtSep "," (map prtFs fss) ++ "]"
	  prtFs fs = "[" ++ prtSep "," (map prtPlForest fs) ++ "]"

prtPlQuoted str = "'" ++ prt str ++ "'"



