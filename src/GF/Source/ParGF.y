-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module GF.Source.ParGF where
import GF.Source.AbsGF
import GF.Source.LexGF
import GF.Data.ErrM
import qualified Data.ByteString.Char8 as BS
}

%name pGrammar Grammar
%name pModDef ModDef
%name pOldGrammar OldGrammar
%partial pModHeader ModHeader
%name pExp Exp

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 '!' { PT _ (TS _ 1) }
 '#' { PT _ (TS _ 2) }
 '$' { PT _ (TS _ 3) }
 '%' { PT _ (TS _ 4) }
 '(' { PT _ (TS _ 5) }
 ')' { PT _ (TS _ 6) }
 '*' { PT _ (TS _ 7) }
 '**' { PT _ (TS _ 8) }
 '+' { PT _ (TS _ 9) }
 '++' { PT _ (TS _ 10) }
 ',' { PT _ (TS _ 11) }
 '-' { PT _ (TS _ 12) }
 '->' { PT _ (TS _ 13) }
 '.' { PT _ (TS _ 14) }
 '/' { PT _ (TS _ 15) }
 ':' { PT _ (TS _ 16) }
 ';' { PT _ (TS _ 17) }
 '<' { PT _ (TS _ 18) }
 '=' { PT _ (TS _ 19) }
 '=>' { PT _ (TS _ 20) }
 '>' { PT _ (TS _ 21) }
 '?' { PT _ (TS _ 22) }
 '@' { PT _ (TS _ 23) }
 'Lin' { PT _ (TS _ 24) }
 'PType' { PT _ (TS _ 25) }
 'Str' { PT _ (TS _ 26) }
 'Strs' { PT _ (TS _ 27) }
 'Tok' { PT _ (TS _ 28) }
 'Type' { PT _ (TS _ 29) }
 '[' { PT _ (TS _ 30) }
 '\\' { PT _ (TS _ 31) }
 ']' { PT _ (TS _ 32) }
 '_' { PT _ (TS _ 33) }
 'abstract' { PT _ (TS _ 34) }
 'case' { PT _ (TS _ 35) }
 'cat' { PT _ (TS _ 36) }
 'concrete' { PT _ (TS _ 37) }
 'data' { PT _ (TS _ 38) }
 'def' { PT _ (TS _ 39) }
 'flags' { PT _ (TS _ 40) }
 'fn' { PT _ (TS _ 41) }
 'fun' { PT _ (TS _ 42) }
 'grammar' { PT _ (TS _ 43) }
 'in' { PT _ (TS _ 44) }
 'include' { PT _ (TS _ 45) }
 'incomplete' { PT _ (TS _ 46) }
 'instance' { PT _ (TS _ 47) }
 'interface' { PT _ (TS _ 48) }
 'let' { PT _ (TS _ 49) }
 'lin' { PT _ (TS _ 50) }
 'lincat' { PT _ (TS _ 51) }
 'lindef' { PT _ (TS _ 52) }
 'lintype' { PT _ (TS _ 53) }
 'of' { PT _ (TS _ 54) }
 'open' { PT _ (TS _ 55) }
 'oper' { PT _ (TS _ 56) }
 'out' { PT _ (TS _ 57) }
 'package' { PT _ (TS _ 58) }
 'param' { PT _ (TS _ 59) }
 'pattern' { PT _ (TS _ 60) }
 'pre' { PT _ (TS _ 61) }
 'printname' { PT _ (TS _ 62) }
 'resource' { PT _ (TS _ 63) }
 'reuse' { PT _ (TS _ 64) }
 'strs' { PT _ (TS _ 65) }
 'table' { PT _ (TS _ 66) }
 'tokenizer' { PT _ (TS _ 67) }
 'transfer' { PT _ (TS _ 68) }
 'union' { PT _ (TS _ 69) }
 'var' { PT _ (TS _ 70) }
 'variants' { PT _ (TS _ 71) }
 'where' { PT _ (TS _ 72) }
 'with' { PT _ (TS _ 73) }
 '{' { PT _ (TS _ 74) }
 '|' { PT _ (TS _ 75) }
 '}' { PT _ (TS _ 76) }

L_integ  { PT _ (TI $$) }
L_quoted { PT _ (TL $$) }
L_doubl  { PT _ (TD $$) }
L_LString { PT _ (T_LString $$) }
L_PIdent { PT _ (T_PIdent _) }
L_err    { _ }


%%

Integer :: { Integer } : L_integ  { (read (BS.unpack $1)) :: Integer }
String  :: { String }  : L_quoted { BS.unpack $1 }
Double  :: { Double }  : L_doubl  { (read (BS.unpack $1)) :: Double }
LString    :: { LString} : L_LString { LString ($1)}
PIdent    :: { PIdent} : L_PIdent { PIdent (mkPosToken $1)}

Grammar :: { Grammar }
Grammar : ListModDef { Gr (reverse $1) } 


ListModDef :: { [ModDef] }
ListModDef : {- empty -} { [] } 
  | ListModDef ModDef { flip (:) $1 $2 }


ModDef :: { ModDef }
ModDef : ModDef ';' { $1 } 
  | 'grammar' PIdent '=' '{' 'abstract' '=' PIdent ';' ListConcSpec '}' { MMain $2 $7 $9 }
  | ComplMod ModType '=' ModBody { MModule $1 $2 $4 }


ConcSpec :: { ConcSpec }
ConcSpec : PIdent '=' ConcExp { ConcSpec $1 $3 } 


ListConcSpec :: { [ConcSpec] }
ListConcSpec : {- empty -} { [] } 
  | ConcSpec { (:[]) $1 }
  | ConcSpec ';' ListConcSpec { (:) $1 $3 }


ConcExp :: { ConcExp }
ConcExp : PIdent ListTransfer { ConcExp $1 (reverse $2) } 


ListTransfer :: { [Transfer] }
ListTransfer : {- empty -} { [] } 
  | ListTransfer Transfer { flip (:) $1 $2 }


Transfer :: { Transfer }
Transfer : '(' 'transfer' 'in' Open ')' { TransferIn $4 } 
  | '(' 'transfer' 'out' Open ')' { TransferOut $4 }


ModHeader :: { ModHeader }
ModHeader : ComplMod ModType '=' ModHeaderBody { MModule2 $1 $2 $4 } 


ModHeaderBody :: { ModHeaderBody }
ModHeaderBody : Extend Opens { MBody2 $1 $2 } 
  | ListIncluded { MNoBody2 $1 }
  | Included 'with' ListOpen { MWith2 $1 $3 }
  | Included 'with' ListOpen '**' Opens { MWithBody2 $1 $3 $5 }
  | ListIncluded '**' Included 'with' ListOpen { MWithE2 $1 $3 $5 }
  | ListIncluded '**' Included 'with' ListOpen '**' Opens { MWithEBody2 $1 $3 $5 $7 }
  | 'reuse' PIdent { MReuse2 $2 }
  | 'union' ListIncluded { MUnion2 $2 }


ModType :: { ModType }
ModType : 'abstract' PIdent { MTAbstract $2 } 
  | 'resource' PIdent { MTResource $2 }
  | 'interface' PIdent { MTInterface $2 }
  | 'concrete' PIdent 'of' PIdent { MTConcrete $2 $4 }
  | 'instance' PIdent 'of' PIdent { MTInstance $2 $4 }
  | 'transfer' PIdent ':' Open '->' Open { MTTransfer $2 $4 $6 }


ModBody :: { ModBody }
ModBody : Extend Opens '{' ListTopDef '}' { MBody $1 $2 (reverse $4) } 
  | ListIncluded { MNoBody $1 }
  | Included 'with' ListOpen { MWith $1 $3 }
  | Included 'with' ListOpen '**' Opens '{' ListTopDef '}' { MWithBody $1 $3 $5 (reverse $7) }
  | ListIncluded '**' Included 'with' ListOpen { MWithE $1 $3 $5 }
  | ListIncluded '**' Included 'with' ListOpen '**' Opens '{' ListTopDef '}' { MWithEBody $1 $3 $5 $7 (reverse $9) }
  | 'reuse' PIdent { MReuse $2 }
  | 'union' ListIncluded { MUnion $2 }


ListTopDef :: { [TopDef] }
ListTopDef : {- empty -} { [] } 
  | ListTopDef TopDef { flip (:) $1 $2 }


Extend :: { Extend }
Extend : ListIncluded '**' { Ext $1 } 
  | {- empty -} { NoExt }


ListOpen :: { [Open] }
ListOpen : {- empty -} { [] } 
  | Open { (:[]) $1 }
  | Open ',' ListOpen { (:) $1 $3 }


Opens :: { Opens }
Opens : {- empty -} { NoOpens } 
  | 'open' ListOpen 'in' { OpenIn $2 }


Open :: { Open }
Open : PIdent { OName $1 } 
  | '(' QualOpen PIdent ')' { OQualQO $2 $3 }
  | '(' QualOpen PIdent '=' PIdent ')' { OQual $2 $3 $5 }


ComplMod :: { ComplMod }
ComplMod : {- empty -} { CMCompl } 
  | 'incomplete' { CMIncompl }


QualOpen :: { QualOpen }
QualOpen : {- empty -} { QOCompl } 
  | 'incomplete' { QOIncompl }
  | 'interface' { QOInterface }


ListIncluded :: { [Included] }
ListIncluded : {- empty -} { [] } 
  | Included { (:[]) $1 }
  | Included ',' ListIncluded { (:) $1 $3 }


Included :: { Included }
Included : PIdent { IAll $1 } 
  | PIdent '[' ListPIdent ']' { ISome $1 $3 }
  | PIdent '-' '[' ListPIdent ']' { IMinus $1 $4 }


Def :: { Def }
Def : ListName ':' Exp { DDecl $1 $3 } 
  | ListName '=' Exp { DDef $1 $3 }
  | Name ListPatt '=' Exp { DPatt $1 $2 $4 }
  | ListName ':' Exp '=' Exp { DFull $1 $3 $5 }


TopDef :: { TopDef }
TopDef : 'cat' ListCatDef { DefCat $2 } 
  | 'fun' ListFunDef { DefFun $2 }
  | 'data' ListFunDef { DefFunData $2 }
  | 'def' ListDef { DefDef $2 }
  | 'data' ListDataDef { DefData $2 }
  | 'transfer' ListDef { DefTrans $2 }
  | 'param' ListParDef { DefPar $2 }
  | 'oper' ListDef { DefOper $2 }
  | 'lincat' ListPrintDef { DefLincat $2 }
  | 'lindef' ListDef { DefLindef $2 }
  | 'lin' ListDef { DefLin $2 }
  | 'printname' 'cat' ListPrintDef { DefPrintCat $3 }
  | 'printname' 'fun' ListPrintDef { DefPrintFun $3 }
  | 'flags' ListFlagDef { DefFlag $2 }
  | 'printname' ListPrintDef { DefPrintOld $2 }
  | 'lintype' ListDef { DefLintype $2 }
  | 'pattern' ListDef { DefPattern $2 }
  | 'package' PIdent '=' '{' ListTopDef '}' ';' { DefPackage $2 (reverse $5) }
  | 'var' ListDef { DefVars $2 }
  | 'tokenizer' PIdent ';' { DefTokenizer $2 }


CatDef :: { CatDef }
CatDef : PIdent ListDDecl { SimpleCatDef $1 (reverse $2) } 
  | '[' PIdent ListDDecl ']' { ListCatDef $2 (reverse $3) }
  | '[' PIdent ListDDecl ']' '{' Integer '}' { ListSizeCatDef $2 (reverse $3) $6 }


FunDef :: { FunDef }
FunDef : ListPIdent ':' Exp { FunDef $1 $3 } 


DataDef :: { DataDef }
DataDef : PIdent '=' ListDataConstr { DataDef $1 $3 } 


DataConstr :: { DataConstr }
DataConstr : PIdent { DataId $1 } 
  | PIdent '.' PIdent { DataQId $1 $3 }


ListDataConstr :: { [DataConstr] }
ListDataConstr : {- empty -} { [] } 
  | DataConstr { (:[]) $1 }
  | DataConstr '|' ListDataConstr { (:) $1 $3 }


ParDef :: { ParDef }
ParDef : PIdent '=' ListParConstr { ParDefDir $1 $3 } 
  | PIdent '=' '(' 'in' PIdent ')' { ParDefIndir $1 $5 }
  | PIdent { ParDefAbs $1 }


ParConstr :: { ParConstr }
ParConstr : PIdent ListDDecl { ParConstr $1 (reverse $2) } 


PrintDef :: { PrintDef }
PrintDef : ListName '=' Exp { PrintDef $1 $3 } 


FlagDef :: { FlagDef }
FlagDef : PIdent '=' PIdent { FlagDef $1 $3 } 


ListDef :: { [Def] }
ListDef : Def ';' { (:[]) $1 } 
  | Def ';' ListDef { (:) $1 $3 }


ListCatDef :: { [CatDef] }
ListCatDef : CatDef ';' { (:[]) $1 } 
  | CatDef ';' ListCatDef { (:) $1 $3 }


ListFunDef :: { [FunDef] }
ListFunDef : FunDef ';' { (:[]) $1 } 
  | FunDef ';' ListFunDef { (:) $1 $3 }


ListDataDef :: { [DataDef] }
ListDataDef : DataDef ';' { (:[]) $1 } 
  | DataDef ';' ListDataDef { (:) $1 $3 }


ListParDef :: { [ParDef] }
ListParDef : ParDef ';' { (:[]) $1 } 
  | ParDef ';' ListParDef { (:) $1 $3 }


ListPrintDef :: { [PrintDef] }
ListPrintDef : PrintDef ';' { (:[]) $1 } 
  | PrintDef ';' ListPrintDef { (:) $1 $3 }


ListFlagDef :: { [FlagDef] }
ListFlagDef : FlagDef ';' { (:[]) $1 } 
  | FlagDef ';' ListFlagDef { (:) $1 $3 }


ListParConstr :: { [ParConstr] }
ListParConstr : {- empty -} { [] } 
  | ParConstr { (:[]) $1 }
  | ParConstr '|' ListParConstr { (:) $1 $3 }


ListPIdent :: { [PIdent] }
ListPIdent : PIdent { (:[]) $1 } 
  | PIdent ',' ListPIdent { (:) $1 $3 }


Name :: { Name }
Name : PIdent { IdentName $1 } 
  | '[' PIdent ']' { ListName $2 }


ListName :: { [Name] }
ListName : Name { (:[]) $1 } 
  | Name ',' ListName { (:) $1 $3 }


LocDef :: { LocDef }
LocDef : ListPIdent ':' Exp { LDDecl $1 $3 } 
  | ListPIdent '=' Exp { LDDef $1 $3 }
  | ListPIdent ':' Exp '=' Exp { LDFull $1 $3 $5 }


ListLocDef :: { [LocDef] }
ListLocDef : {- empty -} { [] } 
  | LocDef { (:[]) $1 }
  | LocDef ';' ListLocDef { (:) $1 $3 }


Exp6 :: { Exp }
Exp6 : PIdent { EIdent $1 } 
  | '{' PIdent '}' { EConstr $2 }
  | '%' PIdent '%' { ECons $2 }
  | Sort { ESort $1 }
  | String { EString $1 }
  | Integer { EInt $1 }
  | Double { EFloat $1 }
  | '?' { EMeta }
  | '[' ']' { EEmpty }
  | 'data' { EData }
  | '[' PIdent Exps ']' { EList $2 $3 }
  | '[' String ']' { EStrings $2 }
  | '{' ListLocDef '}' { ERecord $2 }
  | '<' ListTupleComp '>' { ETuple $2 }
  | '(' 'in' PIdent ')' { EIndir $3 }
  | '<' Exp ':' Exp '>' { ETyped $2 $4 }
  | '(' Exp ')' { $2 }
  | LString { ELString $1 }


Exp5 :: { Exp }
Exp5 : Exp5 '.' Label { EProj $1 $3 } 
  | '{' PIdent '.' PIdent '}' { EQConstr $2 $4 }
  | '%' PIdent '.' PIdent { EQCons $2 $4 }
  | Exp6 { $1 }


Exp4 :: { Exp }
Exp4 : Exp4 Exp5 { EApp $1 $2 } 
  | 'table' '{' ListCase '}' { ETable $3 }
  | 'table' Exp6 '{' ListCase '}' { ETTable $2 $4 }
  | 'table' Exp6 '[' ListExp ']' { EVTable $2 $4 }
  | 'case' Exp 'of' '{' ListCase '}' { ECase $2 $5 }
  | 'variants' '{' ListExp '}' { EVariants $3 }
  | 'pre' '{' Exp ';' ListAltern '}' { EPre $3 $5 }
  | 'strs' '{' ListExp '}' { EStrs $3 }
  | PIdent '@' Exp6 { EConAt $1 $3 }
  | '#' Patt2 { EPatt $2 }
  | 'pattern' Exp5 { EPattType $2 }
  | Exp5 { $1 }
  | 'Lin' PIdent { ELin $2 }


Exp3 :: { Exp }
Exp3 : Exp3 '!' Exp4 { ESelect $1 $3 } 
  | Exp3 '*' Exp4 { ETupTyp $1 $3 }
  | Exp3 '**' Exp4 { EExtend $1 $3 }
  | Exp4 { $1 }


Exp2 :: { Exp }
Exp2 : Exp3 '+' Exp2 { EGlue $1 $3 } 
  | Exp3 { $1 }


Exp1 :: { Exp }
Exp1 : Exp2 '++' Exp1 { EConcat $1 $3 } 
  | Exp2 { $1 }


Exp :: { Exp }
Exp : Exp1 '|' Exp { EVariant $1 $3 } 
  | '\\' ListBind '->' Exp { EAbstr $2 $4 }
  | '\\' '\\' ListBind '=>' Exp { ECTable $3 $5 }
  | Decl '->' Exp { EProd $1 $3 }
  | Exp3 '=>' Exp { ETType $1 $3 }
  | 'let' '{' ListLocDef '}' 'in' Exp { ELet $3 $6 }
  | 'let' ListLocDef 'in' Exp { ELetb $2 $4 }
  | Exp3 'where' '{' ListLocDef '}' { EWhere $1 $4 }
  | 'fn' '{' ListEquation '}' { EEqs $3 }
  | 'in' Exp5 String { EExample $2 $3 }
  | Exp1 { $1 }


ListExp :: { [Exp] }
ListExp : {- empty -} { [] } 
  | Exp { (:[]) $1 }
  | Exp ';' ListExp { (:) $1 $3 }


Exps :: { Exps }
Exps : {- empty -} { NilExp } 
  | Exp6 Exps { ConsExp $1 $2 }


Patt2 :: { Patt }
Patt2 : '?' { PChar } 
  | '[' String ']' { PChars $2 }
  | '#' PIdent { PMacro $2 }
  | '#' PIdent '.' PIdent { PM $2 $4 }
  | '_' { PW }
  | PIdent { PV $1 }
  | '{' PIdent '}' { PCon $2 }
  | PIdent '.' PIdent { PQ $1 $3 }
  | Integer { PInt $1 }
  | Double { PFloat $1 }
  | String { PStr $1 }
  | '{' ListPattAss '}' { PR $2 }
  | '<' ListPattTupleComp '>' { PTup $2 }
  | '(' Patt ')' { $2 }


Patt1 :: { Patt }
Patt1 : PIdent ListPatt { PC $1 $2 } 
  | PIdent '.' PIdent ListPatt { PQC $1 $3 $4 }
  | Patt2 '*' { PRep $1 }
  | PIdent '@' Patt2 { PAs $1 $3 }
  | '-' Patt2 { PNeg $2 }
  | Patt2 { $1 }


Patt :: { Patt }
Patt : Patt '|' Patt1 { PDisj $1 $3 } 
  | Patt '+' Patt1 { PSeq $1 $3 }
  | Patt1 { $1 }


PattAss :: { PattAss }
PattAss : ListPIdent '=' Patt { PA $1 $3 } 


Label :: { Label }
Label : PIdent { LIdent $1 } 
  | '$' Integer { LVar $2 }


Sort :: { Sort }
Sort : 'Type' { Sort_Type } 
  | 'PType' { Sort_PType }
  | 'Tok' { Sort_Tok }
  | 'Str' { Sort_Str }
  | 'Strs' { Sort_Strs }


ListPattAss :: { [PattAss] }
ListPattAss : {- empty -} { [] } 
  | PattAss { (:[]) $1 }
  | PattAss ';' ListPattAss { (:) $1 $3 }


ListPatt :: { [Patt] }
ListPatt : Patt2 { (:[]) $1 } 
  | Patt2 ListPatt { (:) $1 $2 }


Bind :: { Bind }
Bind : PIdent { BIdent $1 } 
  | '_' { BWild }


ListBind :: { [Bind] }
ListBind : {- empty -} { [] } 
  | Bind { (:[]) $1 }
  | Bind ',' ListBind { (:) $1 $3 }


Decl :: { Decl }
Decl : '(' ListBind ':' Exp ')' { DDec $2 $4 } 
  | Exp4 { DExp $1 }


TupleComp :: { TupleComp }
TupleComp : Exp { TComp $1 } 


PattTupleComp :: { PattTupleComp }
PattTupleComp : Patt { PTComp $1 } 


ListTupleComp :: { [TupleComp] }
ListTupleComp : {- empty -} { [] } 
  | TupleComp { (:[]) $1 }
  | TupleComp ',' ListTupleComp { (:) $1 $3 }


ListPattTupleComp :: { [PattTupleComp] }
ListPattTupleComp : {- empty -} { [] } 
  | PattTupleComp { (:[]) $1 }
  | PattTupleComp ',' ListPattTupleComp { (:) $1 $3 }


Case :: { Case }
Case : Patt '=>' Exp { Case $1 $3 } 


ListCase :: { [Case] }
ListCase : Case { (:[]) $1 } 
  | Case ';' ListCase { (:) $1 $3 }


Equation :: { Equation }
Equation : ListPatt '->' Exp { Equ $1 $3 } 


ListEquation :: { [Equation] }
ListEquation : {- empty -} { [] } 
  | Equation { (:[]) $1 }
  | Equation ';' ListEquation { (:) $1 $3 }


Altern :: { Altern }
Altern : Exp '/' Exp { Alt $1 $3 } 


ListAltern :: { [Altern] }
ListAltern : {- empty -} { [] } 
  | Altern { (:[]) $1 }
  | Altern ';' ListAltern { (:) $1 $3 }


DDecl :: { DDecl }
DDecl : '(' ListBind ':' Exp ')' { DDDec $2 $4 } 
  | Exp6 { DDExp $1 }


ListDDecl :: { [DDecl] }
ListDDecl : {- empty -} { [] } 
  | ListDDecl DDecl { flip (:) $1 $2 }


OldGrammar :: { OldGrammar }
OldGrammar : Include ListTopDef { OldGr $1 (reverse $2) } 


Include :: { Include }
Include : {- empty -} { NoIncl } 
  | 'include' ListFileName { Incl $2 }


FileName :: { FileName }
FileName : String { FString $1 } 
  | PIdent { FIdent $1 }
  | '/' FileName { FSlash $2 }
  | '.' FileName { FDot $2 }
  | '-' FileName { FMinus $2 }
  | PIdent FileName { FAddId $1 $2 }


ListFileName :: { [FileName] }
ListFileName : FileName ';' { (:[]) $1 } 
  | FileName ';' ListFileName { (:) $1 $3 }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (BS.unpack . prToken) (take 4 ts))

myLexer = tokens
}

