-- This Happy file was machine-generated by the BNF converter
{
module ParCFG where
import AbsCFG
import LexCFG
import ErrM
}

%name pGrammars Grammars

%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 ';' { PT _ (TS ";") }
 ':' { PT _ (TS ":") }
 '.' { PT _ (TS ".") }
 '->' { PT _ (TS "->") }
 '[' { PT _ (TS "[") }
 ']' { PT _ (TS "]") }
 ',' { PT _ (TS ",") }
 '/' { PT _ (TS "/") }
 '{' { PT _ (TS "{") }
 '}' { PT _ (TS "}") }
 '!' { PT _ (TS "!") }
 '=' { PT _ (TS "=") }
 '(' { PT _ (TS "(") }
 ')' { PT _ (TS ")") }
 'end' { PT _ (TS "end") }
 'grammar' { PT _ (TS "grammar") }
 'startcat' { PT _ (TS "startcat") }

L_ident  { PT _ (TV $$) }
L_integ  { PT _ (TI $$) }
L_quoted { PT _ (TL $$) }
L_err    { _ }


%%

Ident   : L_ident  { Ident $1 }
Integer : L_integ  { (read $1) :: Integer }
String  : L_quoted { $1 }

Grammars :: { Grammars }
Grammars : ListGrammar { Grammars (reverse $1) } 


Grammar :: { Grammar }
Grammar : 'grammar' Ident ListFlag ListRule 'end' 'grammar' { Grammar $2 (reverse $3) (reverse $4) } 


ListGrammar :: { [Grammar] }
ListGrammar : {- empty -} { [] } 
  | ListGrammar Grammar { flip (:) $1 $2 }


Flag :: { Flag }
Flag : 'startcat' Category { StartCat $2 } 


ListFlag :: { [Flag] }
ListFlag : {- empty -} { [] } 
  | ListFlag Flag ';' { flip (:) $1 $2 }


Rule :: { Rule }
Rule : Ident ':' Name Profile '.' Category '->' ListSymbol { Rule $1 $3 $4 $6 $8 } 


ListRule :: { [Rule] }
ListRule : {- empty -} { [] } 
  | ListRule Rule ';' { flip (:) $1 $2 }


Profile :: { Profile }
Profile : '[' ListInts ']' { Profile $2 } 


Ints :: { Ints }
Ints : '[' ListInteger ']' { Ints $2 } 


ListInts :: { [Ints] }
ListInts : {- empty -} { [] } 
  | Ints { (:[]) $1 }
  | Ints ',' ListInts { (:) $1 $3 }


ListInteger :: { [Integer] }
ListInteger : {- empty -} { [] } 
  | Integer { (:[]) $1 }
  | Integer ',' ListInteger { (:) $1 $3 }


Symbol :: { Symbol }
Symbol : Category { CatS $1 } 
  | String { TermS $1 }


ListSymbol :: { [Symbol] }
ListSymbol : '.' { [] } 
  | Symbol { (:[]) $1 }
  | Symbol ListSymbol { (:) $1 $2 }


Name :: { Name }
Name : ListIdentParam Category { Name (reverse $1) $2 } 


ListIdentParam :: { [IdentParam] }
ListIdentParam : {- empty -} { [] } 
  | ListIdentParam IdentParam '/' { flip (:) $1 $2 }


Category :: { Category }
Category : IdentParam '.' Ident ListProj { Category $1 $3 (reverse $4) } 


IdentParam :: { IdentParam }
IdentParam : Ident '{' ListField '}' { IdentParam $1 (reverse $3) } 


Field :: { Field }
Field : '.' KeyValue { Field $2 } 


ListField :: { [Field] }
ListField : {- empty -} { [] } 
  | ListField Field ';' { flip (:) $1 $2 }


Proj :: { Proj }
Proj : '!' Param { Proj $2 } 


ListProj :: { [Proj] }
ListProj : {- empty -} { [] } 
  | ListProj Proj { flip (:) $1 $2 }


KeyValue :: { KeyValue }
KeyValue : Ident '=' Param { KeyValue $1 $3 } 


ListKeyValue :: { [KeyValue] }
ListKeyValue : {- empty -} { [] } 
  | KeyValue { (:[]) $1 }
  | KeyValue ';' ListKeyValue { (:) $1 $3 }


Param :: { Param }
Param : Ident { ParamSimple $1 } 
  | Ident '(' ListParam ')' { ParamPatt $1 $3 }
  | '{' ListKeyValue '}' { ParamRec $2 }


ListParam :: { [Param] }
ListParam : {- empty -} { [] } 
  | Param { (:[]) $1 }
  | Param ',' ListParam { (:) $1 $3 }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ if null ts then [] else (" before " ++ unwords (map prToken (take 4 ts)))

myLexer = tokens
}

