-- automatically generated by BNF Converter
module Main where


import Trees
import Profile
import IO ( stdin, hGetContents )
import System ( getArgs, getProgName )

import LexImperC
import ParImperC
import ErrM

type ParseFun = [Token] -> Err CFTree

myLLexer = myLexer

runFile :: ParseFun -> FilePath -> IO ()
runFile p f = readFile f >>= run p

run :: ParseFun -> String -> IO ()
run p s = do
  let ts = myLLexer s
  let etree = p ts
  case etree of
    Ok tree -> do
      case postParse tree of
        Bad s    -> do
          putStrLn "\nParse Failed... CFTree:\n"
          putStrLn $ prCFTree tree
          putStrLn s
        Ok  tree -> do
          putStrLn "\nParse Successful!"
          putStrLn $ "\n[Abstract Syntax]\n\n" ++ prt tree
    Bad s -> do
      putStrLn s
      putStrLn "\nParse failed... tokenization:"
      print ts

main :: IO ()
main = do args <- getArgs
          case args of
            []  -> hGetContents stdin >>= run pProgram
            [f] -> runFile pProgram f
            _   -> do progName <- getProgName
                      putStrLn $ progName ++ ": excess arguments."
