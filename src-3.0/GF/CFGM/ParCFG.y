-- This Happy file was machine-generated by the BNF converter
{
module ParCFG where
import AbsCFG
import LexCFG
import ErrM
}

%name pGrammars Grammars

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 ';' { PT _ (TS ";") }
 ':' { PT _ (TS ":") }
 '.' { PT _ (TS ".") }
 '->' { PT _ (TS "->") }
 '_' { PT _ (TS "_") }
 '[' { PT _ (TS "[") }
 ']' { PT _ (TS "]") }
 ',' { PT _ (TS ",") }
 'end' { PT _ (TS "end") }
 'grammar' { PT _ (TS "grammar") }
 'startcat' { PT _ (TS "startcat") }

L_ident  { PT _ (TV $$) }
L_integ  { PT _ (TI $$) }
L_quoted { PT _ (TL $$) }
L_SingleQuoteString { PT _ (T_SingleQuoteString $$) }
L_err    { _ }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
Integer :: { Integer } : L_integ  { (read $1) :: Integer }
String  :: { String }  : L_quoted { $1 }
SingleQuoteString    :: { SingleQuoteString} : L_SingleQuoteString { SingleQuoteString ($1)}

Grammars :: { Grammars }
Grammars : ListGrammar { Grammars (reverse $1) } 


Grammar :: { Grammar }
Grammar : 'grammar' Ident ListFlag ListRule 'end' 'grammar' { Grammar $2 (reverse $3) (reverse $4) } 


ListGrammar :: { [Grammar] }
ListGrammar : {- empty -} { [] } 
  | ListGrammar Grammar { flip (:) $1 $2 }


Flag :: { Flag }
Flag : 'startcat' Category { StartCat $2 } 


ListFlag :: { [Flag] }
ListFlag : {- empty -} { [] } 
  | ListFlag Flag ';' { flip (:) $1 $2 }


Rule :: { Rule }
Rule : Fun ':' Profiles '.' Category '->' ListSymbol { Rule $1 $3 $5 $7 } 


ListRule :: { [Rule] }
ListRule : {- empty -} { [] } 
  | ListRule Rule ';' { flip (:) $1 $2 }


Fun :: { Fun }
Fun : Ident { Cons $1 } 
  | '_' { Coerce }


Profiles :: { Profiles }
Profiles : '[' ListProfile ']' { Profiles $2 } 


ListProfile :: { [Profile] }
ListProfile : {- empty -} { [] } 
  | Profile { (:[]) $1 }
  | Profile ',' ListProfile { (:) $1 $3 }


Profile :: { Profile }
Profile : '[' ListInteger ']' { UnifyProfile $2 } 
  | Ident { ConstProfile $1 }


ListInteger :: { [Integer] }
ListInteger : {- empty -} { [] } 
  | Integer { (:[]) $1 }
  | Integer ',' ListInteger { (:) $1 $3 }


Symbol :: { Symbol }
Symbol : Category { CatS $1 } 
  | String { TermS $1 }


ListSymbol :: { [Symbol] }
ListSymbol : '.' { [] } 
  | Symbol { (:[]) $1 }
  | Symbol ListSymbol { (:) $1 $2 }


Category :: { Category }
Category : SingleQuoteString { Category $1 } 



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ if null ts then [] else (" before " ++ unwords (map prToken (take 4 ts)))

myLexer = tokens
}

