module GF.GFCC.DataGFCC where

import GF.GFCC.CId
import GF.Infra.PrintClass(prt)
import GF.Infra.CompactPrint
import GF.Text.UTF8
import GF.Data.Assoc

import qualified Data.Map as Map
import Data.List
import Data.Array

-- internal datatypes for GFCC

data GFCC = GFCC {
  absname   :: CId ,
  cncnames  :: [CId] ,
  gflags    :: Map.Map CId String,   -- value of a global flag
  abstract  :: Abstr ,
  concretes :: Map.Map CId Concr
  }

data Abstr = Abstr {
  aflags  :: Map.Map CId String,     -- value of a flag
  funs    :: Map.Map CId (Type,Exp), -- type and def of a fun
  cats    :: Map.Map CId [Hypo],     -- context of a cat
  catfuns :: Map.Map CId [CId]       -- funs to a cat (redundant, for fast lookup)
  }

data Concr = Concr {
  cflags  :: Map.Map CId String,    -- value of a flag
  lins    :: Map.Map CId Term,      -- lin of a fun
  opers   :: Map.Map CId Term,      -- oper generated by subex elim
  lincats :: Map.Map CId Term,      -- lin type of a cat
  lindefs :: Map.Map CId Term,      -- lin default of a cat
  printnames :: Map.Map CId Term,   -- printname of a cat or a fun
  paramlincats :: Map.Map CId Term, -- lin type of cat, with printable param names
  parser  :: Maybe ParserInfo       -- parser
  }

data Type =
   DTyp [Hypo] CId [Exp]
  deriving (Eq,Ord,Show)

data Exp =
   DTr [CId] Atom [Exp]
 | EEq [Equation]
  deriving (Eq,Ord,Show)

data Atom =
   AC CId
 | AS String
 | AI Integer
 | AF Double
 | AM Integer
 | AV CId
  deriving (Eq,Ord,Show)

data Term =
   R [Term]
 | P Term Term
 | S [Term]
 | K Tokn
 | V Int
 | C Int
 | F CId
 | FV [Term]
 | W String Term
 | TM String
  deriving (Eq,Ord,Show)

data Tokn =
   KS String
 | KP [String] [Variant]
  deriving (Eq,Ord,Show)

data Variant =
   Var [String] [String]
  deriving (Eq,Ord,Show)

data Hypo =
   Hyp CId Type
  deriving (Eq,Ord,Show)

data Equation =
   Equ [Exp] Exp
  deriving (Eq,Ord,Show)


type FToken    = String
type FCat      = Int
type FIndex    = Int
data FSymbol
  = FSymCat {-# UNPACK #-} !FIndex {-# UNPACK #-} !Int
  | FSymTok FToken
type Profile   = [Int]
type FPointPos = Int
type FGrammar  = ([FRule], Map.Map CId [FCat])
data FRule     = FRule CId [Profile] [FCat] FCat (Array FIndex (Array FPointPos FSymbol))

type RuleId = Int

data ParserInfo
    = ParserInfo { allRules           :: Array RuleId FRule
                 , topdownRules       :: Assoc FCat [RuleId]
	  	   -- ^ used in 'GF.Parsing.MCFG.Active' (Earley):
	           -- , emptyRules    :: [RuleId]
	         , epsilonRules       :: [RuleId]
		   -- ^ used in 'GF.Parsing.MCFG.Active' (Kilbury):
	         , leftcornerCats     :: Assoc FCat   [RuleId]
	         , leftcornerTokens   :: Assoc FToken [RuleId]
		   -- ^ used in 'GF.Parsing.MCFG.Active' (Kilbury):
	         , grammarCats        :: [FCat]
	         , grammarToks        :: [FToken]
	         , startupCats        :: Map.Map CId [FCat]
	         }


fcatString, fcatInt, fcatFloat, fcatVar :: Int
fcatString = (-1)
fcatInt    = (-2)
fcatFloat  = (-3)
fcatVar    = (-4)


-- print statistics

statGFCC :: GFCC -> String
statGFCC gfcc = unlines [
  "Abstract\t" ++ prCId (absname gfcc), 
  "Concretes\t" ++ unwords (map prCId (cncnames gfcc)), 
  "Categories\t" ++ unwords (map prCId (Map.keys (cats (abstract gfcc)))) 
  ]

-- merge two GFCCs; fails is differens absnames; priority to second arg

unionGFCC :: GFCC -> GFCC -> GFCC
unionGFCC one two = case absname one of
  n | n == wildCId     -> two    -- extending empty grammar
    | n == absname two -> one {  -- extending grammar with same abstract
      concretes = Map.union (concretes two) (concretes one),
      cncnames  = union (cncnames two) (cncnames one)
    }
  _ -> one   -- abstracts don't match ---- print error msg

emptyGFCC :: GFCC
emptyGFCC = GFCC {
  absname   = wildCId,
  cncnames  = [] ,
  gflags    = Map.empty,
  abstract  = error "empty grammar, no abstract",
  concretes = Map.empty
  }

-- encode idenfifiers and strings in UTF8

utf8GFCC :: GFCC -> GFCC
utf8GFCC gfcc = gfcc {
  concretes = Map.map u8concr (concretes gfcc)
  }
 where 
   u8concr cnc = cnc {
     lins = Map.map u8term (lins cnc),
     opers = Map.map u8term (opers cnc)
     }
   u8term = convertStringsInTerm encodeUTF8

---- TODO: convert identifiers and flags

convertStringsInTerm conv t = case t of
  K (KS s) -> K (KS (conv s))
  W s r    -> W (conv s) (convs r)
  R ts     -> R $ map convs ts
  S ts     -> S $ map convs ts
  FV ts    -> FV $ map convs ts
  P u v    -> P (convs u) (convs v)
  _        -> t
 where
  convs = convertStringsInTerm conv

